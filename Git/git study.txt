프로젝트 파일을 만듭시다. 
mkdir gitfth

프로젝트 디렉토리로 들어갑니다. 
cd gitfth

현재 디렉토리를 git의 (버전) 저장소로 만듭니다. 
git init

파일을 생성합니다. 
vim f1.txt

git이 파일을 추적하도록 명령합니다. 
git add f1.txt

프로젝트 폴더의 상태를 확인합니다. 
git status
-----------------------------------------------------------------------------------------------------------------------------------------------

버전에 포함될 버전을 만든 사람에 대한 정보를 설정합니다. 이 설정은 ~/.gitconfig 파일에 저장되고 1번만 해주면 됩니다.
git config --global user.name "자신의 닉네임"
git config --global user.email "자신의 이메일"
-----------------------------------------------------------------------------------------------------------------------------------------------
수업에서 사용된 명령어
로그에서 출력되는 버전 간의 차이점을 출력하고 싶을 때 
git log -p 

버전 간의 차이점을 비교할 때
git diff '버전 id'..'버전 id2'

git add하기 전과 add한 후의 파일 내용을 비교할 때 
git diff
-----------------------------------------------------------------------------------------------------------------------------------------------
수업에서 사용한 명령
아래 명령은 버전 id로 돌아가는 명령입니다. 
git reset --hard "버전 id" 
버전 id의 커밋을 취소한 내용을 새로운 버전으로 만드는 명령
git revert "버전 id"

참고
reset과 revert의 차이점에 대해서 재미있게 설명하는 카툰입니다. 
http://www.popit.kr/
-----------------------------------------------------------------------------------------------------------------------------------------------
명령의 빈도수
아래 표는 git의 명령의 중요도를 의미합니다. 여기서 측정한 중요도는 구글 검색엔진에서 얼마나 많은 검색이 있었는가를 기준으로 삼고 있습니다. 정확하지는 않지만 참고삼아서 공유합니다. 이에 따르면 여러분은 중요도면에서 40%에 도달했습니다. 축하드립니다. 

command	google results	%
commit		528,000		7.981980075
push		523,000		7.906393143
pull		506,000		7.649397572
clone		489,000		7.392402002
checkout		470,000		7.105171658
add		446,000		6.742354382
branch		439,000		6.636532676
log		388,000		5.865545964
diff		369,000		5.578315621
fetch		355,000		5.36667221
merge		354,000		5.351554823
init		343,000		5.185263572
status		286,000		4.323572541
reset		267,000		4.036342197
tag		246,000		3.718877081
rebase		203,000		3.068829461
rm		142,000		2.146668884
show		104,000		1.572208197
bisect		62,800		0.9493718726
grep		49,400		0.7467988934
mv		44,700		0.6757471768

git commit 명령어
editor를 켜지 않고 바로 저장 name을 설정할 수 있다.
git commit -am "-------?name?-------"
---------------------------------------------------------------------------------
-branch-

브랜치의 목록을 볼 때
git branch

브랜치를 생성할 때 
git branch "새로운 브랜치 이름"

브랜치를 삭제할 때
git branch -d

병합하지 않은 브랜치를 강제 삭제할 때 
git branch -D

브랜치를 전환(체크아웃)할 때
git checkout "전환하려는 브랜치 이름"

브랜치를 생성하고 전환까지 할 때 
git checkout -b "생성하고 전환할 브랜치 이름"


-->
* f1.txt 생성후 2번 commit 하기
vim f1.txt
git add f1.txt
git commit -m "1"
git log
vim f1.txt
git commit -am "2"
git log

* branch 생성
git branch exp
git branch
git checkout exp
git branch

* exp 브랜치에서 f1.txt 수정
vim f1.txt
git add f1.txt
git commit -m "3"
git log

* master 브랜치로 변경하여 log 확인
git checkout master
git log
cat f1.txt

* exp 브랜치로 이동하여 파일 내용과 커밋버젼 비교
git checkout exp
git log
cat f1.txt

* exp 브랜치에서 f2.txt 추가
vim f2.txt
git add f2.txt
git commit -m "4"

* 브랜치를 전환하여 파일 변경사항 비교
git checkout master
git checkout exp
--------------------------------------------------------------------
브랜치의 목록을 볼 때
git branch

브랜치를 생성할 때 
git branch "새로운 브랜치 이름"

브랜치를 삭제할 때
git branch -d

병합하지 않은 브랜치를 강제 삭제할 때 
git branch -D

브랜치를 전환(체크아웃)할 때
git checkout "전환하려는 브랜치 이름"

브랜치를 생성하고 전환까지 할 때 
git checkout -b "생성하고 전환할 브랜치 이름"
-------------------------------------------------------------------------
브랜치 간에 비교할 때
git log "비교할 브랜치 명 1".."비교할 브랜치 명 2"

브랜치 간의 코드를 비교 할 때 
git diff "비교할 브랜치 명 1".."비교할 브랜치 명 2"

로그에 모든 브랜치를 표시하고, 그래프로 표현하고, 브랜치 명을 표시하고, 한줄로 표시할 때 
git log --branches --graph --decorate --oneline
---------------------------------------------------------------------------
 A 브랜치로 B 브랜치를 병합할 때 (A ← B)
git checkout A
git merge B
-> example
커밋c0-c1-c2가 만들어진 상태에서,
브랜치 하나 만들고($git branch iss53), 그 브랜치로 들어가야겠다($ git checkout iss53)!
아웅 귀찮아, 한번에 하자.
그거슨 ==> $git checkout -b iss53
(현재상태)
master : c0-c1-c2
iss53 : c0-c1-c2-c3

여기서, master에게 긴급하게 만들어야할 (아마 단기적인) 브랜치가 생겼다! master로 체크아웃한 상태에서
$git checkout -b hotfix
이제 hotfix에서 작업(c4만듬) 다 하고나서, hotfix를 master에 merge할때, master로 체크아웃한 상태에서
$git merge hotfix 하면, Fast-forward(빨리감기)가 나옴.

[Fast-forward merge] (commit을 새로 생성안하고 merge한다)
master브런치 c2에 있는상태다. 근데 hotfix가 c4를 만들고 독립했다.
master브런치가 가르키는 commit을 hotfix가 가르키는 commit으로 빨리감기를 하면, 병합이 된다.
이걸 fast-forward라고 한다.
그 결과, master가 hotfix를 가르키게 되며, 이 merge작업을 하면 별도의 commit 생성없이 바로 c4를 가르키게 되는것이다.(wow)

hotfix는 이제 할 일(긴급하게 일시적인일) 다 끝났으니,
$git branch -d hotfix 로 없애줌.

(현재상태)
master : c0-c1-c2-c4 (c2에서 hotfix브런치 만들어서 hotfix에게 c4란 일시키고, hotfix가 c4를 만들면 hotfix있는곳으로가서(hotfix를 merge하면됨) hotfix를 죽여버림(!!), 그리하여 소리소문없이(별도의 commit없이) c4자리에 master가 위치함)
iss53 : c0-c1-c2-c3
심심하니 iss53에 c5하나 만들어서 연결시키셈(~-c3-c5)

이제 iss53을 master로 merge하면 'recursive' mergy를 함.

[fast-forward가 아닌 merge] (commit생성하고 merge하는 흔해빠진 merge)
fast-forward는 안됌.
(master가 c2에서 c4로 변화가 생겨서그럼)
master와 iss53의 공통의 조상(c2)를 찾고, 3-way merge라 하는 내부적인 방법으로 c4와 c5를 합치고,
이 둘을 합침을 알리는 commit을 새로 만듬(c6)

(현재상태)
master : c0-c1-c2-c4- (merge)c6
iss53 : c0-c1-c2-c3-c5 /



* branch를 merge하는 방법 두 가지
1) Fast-forward
2) recursive strategy

----------------------------------------------------------------------------------------
git의 소스코드를 지역저장소로 가져오기
git clone https://github.com/git/git.git gitsrc

로그를 거꾸로 출력하기
git log --reverse

git의 첫번째 커밋으로 체크아웃하기
git checkout e83c5163316f89bfbde7d9ab23ca2e25604af290
-----------------------------------------------------------------------------------------
@ git remote add origin master <원격저장주소>
-> 원격저장소 등록
@ git remote -v
-> 원격저장소 보기
@ git push -u origin master :
-> 앞으로 현재 브랜치를 원격저장소 origin의 master에 동기화하겠다.
@ git remote remove <원격저장소이름>
-> 원격저장소로 등록한 이름과 주소 삭제
-----------------------------------------------------------------------------------------
하나의 원격저장소를 2개의 지역저장소가 사용하는 방법
집에서 작업 + 회사에서 작업 > 복습의 성격
ls -al
git clone 원격저장소의 주소 git_home (저장하고 싶은 디렉토리를 지정) <-- 집에 있는 컴
git clone 원격저장소의 주소 git_office (저장하고 싶은 디렉토리를 지정) <-- 회사에 있는 컴
집에서 프로젝트를 할 경우
vim f1.txt파일의 내용 변경 > 담c > git commit -am 2
git log
3으로 했어야 하는데 > 바꾸면 됨 > git commit --amend (--amend개정하다라는 뜻,
이전 커밋 메시지를 변경가능/커밋할 내용을 누락시켰을 경우에는 add를 한 후 다시 이것을 하면 마지막 메시지를 바꿀 수 있는데
그것은 원격저장소로 올리전에 해야 함(지역저장소에 있는 경우 > 자신의 컴퓨터에 있는 경우에만 해야 되고 그 이후에는 여러분은 하면 안된다고 생각하면 좋음
이유: push이후 내용은 수정하지 마라)
3이라고 내용을 변경하고 :wq
git log > 2가 3으로 변경된 것을 확인할 수 있음
git push > ID + 비번 > 요런식으로 푸쉬가 되고
깃허브에 보니 커밋이 추가되었고 방금 커밋한 것이 올라와 있음(3:55)

작업을 끝내고 회사로 갈 것임
회사에서 작업하기 전에 항상
git pull(당겨온다 )master에 있고 마스터는 오리진에 연결되어 있을 것임
여러분들이 클로닝을 했기 때문에 그런경우 그냥 git pull만 하면 됨
원격저장소의 내용을 로컬저장소로 가져오게 됨
그때 ID와 패스워드를 묻지 않는 것은 여러분이 공개 저장소를 쓰기 때문임
그럼 여기서 작업을 할 것임
ls -al > git log > vim f1.txt > d > git commit -am '4' > git push > ID 패스워드 입력

다시 집으로 와서 (5:17)
git pull > 또 수정하고 푸시하고 > 회사로 가고 반복하면서
여러분들이 일을 해나가는 것
가장 중심적인 것은 백업이 된다는 것
버젼과 소스코드 모두를 다 올리기 때문에 > 모든 저장소들은 모든 것을 각자 다 가지고 있기 때문에
요정도 수준의 백업만 되어 있어도 3개가 동시에 파괴될 소지는 현저히 떨어지기 때문에 > 소스코드를 잃어 버린다는 것은 거의 지구수준의 재앙이 아니면 불가능
이것이 원격저장소의 효용이고 > 여러분이 수련해야 할 시점임 > git pull > git push
어떤 작업을 할 경우 > 반드시 >(git pull로 당기는 것을 먼저하고 작업이 끝나면 꼭 git push를 하는 것을 여러분이 습관화 시키셔야 함)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
