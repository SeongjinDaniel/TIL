# 객체지향 개발 5대 원리: SOLID

- 단어

  - 책임 : 변경을 위한 이유

  - 컴포넌트 : 각각 독립된 모듈을 뜻하며, 이는 흔히 JAVA같은 OOP 언어등의 class의 개념과는 다르다.
    하나의 컴포넌트는 하나의 클래스로만 작성될 수 도 있지만, 여러개의 클래스로도 작성될 수 있다.

    컴포넌트 개념을 잘 적용한 소프트웨어란 부품(인터페이스를 구현받은 class)만 바꾸었을시, 오류없이 잘 작동 되는 것을 의미!



입증된 객체지향 디자인 원리들을 사용하면 좀 더 유지보수하기 쉽고, 유연하고, 확장이 쉬운 소프트웨어를 만들 수 있습니다. 이 원리들은 그 크기를 대비해 보면 패턴보다 훨씬 작지만 표준화 작업에서부터 아키텍처 설계에 이르기까지 다양하게 적용되는 원칙입니다.



### 1. SRP(단일책임의 원칙: Single Responsibility Principle)

**작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임(변경을 위한 이유)을 수행하는 데 집중되어 있어야 한다는 원칙입니다 - 어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다**



책임을 적절히 분배함으로써 코드의 가독성 향상, 유지보수 용이라는 이점까지 누릴 수 있으며 객체지향 원리의 대전제 격인 OCP원리뿐 아니라 다른 원리들을 적용하는 기초가 됩니다.



**각각의 Class들의 유사한 책임들은 부모에게 명백히 위임하고 다른 책임들은 각자에게 정의할 수 있습니다.**



### 2. OCP(개방폐쇄의 원칙: Open Close Principle)

소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 **확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리**입니다. 즉, 요구사항의 변경이나 추가사항이 발생하더라도, **기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻입니다. - 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀있어야 한다**



로버트 C. 마틴은OCP는 **관리가능하고 재사용 가능한 코드를 만드는 기반**이며, OCP를 가능케 하는 중요 메커니즘은 추상화와 다형성이라고 설명하고 있습니다. OCP는 객체지향의 장점을 극대화하는 아주 중요한 원라 할 수 있습니다.



- 적용방법
  - 변경(확장)될 것과 변하지 않을 것을 엄격히 구분합니다.
  - 이 두모듈이 만나는 지점에 인터페이스를 정의합니다.
  - 구현에 의존하기 보다 정의한 인터페이스에 의존하도록 코드를 작성합니다.





### 3. LSP(리스코브 치환의 원칙: The Liskov Substitution Principle)

서브타입은 언제나 기반 타입으로 교체할 수 있어야 합니다 즉, 서브타입은 언제나 기반 타입과 호환될 수 있어야 합니다. **- 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다** 



LSP원리도 역시 서브 클래스가 확장에 대한 인터페이스를 준수해야 함을 의미합니다. 다형성과 확장성을 극대화 하려면 하위 클래스를 사용하는 것보다는 상위 클래스(인터페이스)를 사용하는 것이 더 좋습니다.

- 적용방법
  - 만약 두 개체가 똑같은 일을 한다면 둘을 하나의 클래소로 표현하고 이들을 구분할 수 있는 필드를 둡니다.
  - 똑같은 연산을 제공하지만, 이들을 약간씩 다르게 한다면 공통의 인터페이스를 만들고 둘이 이를 구현 합니다 . (인터페이스 상속)
  - 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만듭니다.
  - 만약 두 개체가 하는 일에 추가적으로 무언가를 더 한다면 구현 상속을 사용합니다.



### 4. ISP(인터페이스 분리의 원칙: Interface Segregation Principle)

어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 합니다. **ISP를 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다라고 정의 할 수 도 있습니다. - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다**

SRP가 클래스의 단일책임을 강조한다면 ISP는 인터페이스의 단일책임을 강조합니다.



- 적용방법
  - **클래스 인터페이스를 통한 분리**
    - **클래스의 상속을 이용하여 인터페이스를 나눌 수 있습니다.** 이와 같은 구조는 클라이언트에게 변화를 주지 않을 뿐 아니라 인터페이스를 분리하는 효과를 갖습니다. 하지만 거의 모든 객체지향 언어에서는 상속을 이용한 확장은 상속받는 클래스의 성격을 디자인 시점에 규정해 버립니다. 따라서 인터페이스를 상속받는 순간 인터페이스에 예속되어 제공하는 서비스의 성격이 제한 됩니다.
  - **객체 인터페이스를 통한 분리**
    - **위임(Delegation)을 이용하여 인터페이스를 나눌 수 있습니다.**
      위임이란, 특정 일의 책임을 다른 클래스나 메소드에 맡기는 것입니다. 만약 다른 클래스의 기능을 사용해야 하지만 그 기능을 변경하고 싶지 않다면, 상속 대신 위임을 사용합니다.



### 5. DIP (의존성역전의 원칙: Dependency Inversion Principle)

**의존 관계의 역전 Dependency Inversion 이란 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전입니다.** 추상을 매개로 메시질ㄹ 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙입니다. **- 자신보다 변하기 쉬운것에 의존하지 마라**



**DIP 키워드는 IOC, 훅메소드**(슈퍼클래스에서 디폴트 기능을 정의해 두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 훅(hook) 메소드라고 합니다.), **확장성**



예제) 헐리우드의 원칙



### 참고

- http://www.nextree.co.kr/p6960/