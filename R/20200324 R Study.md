# 20200324 R Study

- 리스트 (list)
  저장 가능한 데이터의 타입 , 데이터 샛의 종류에 제한이 없다 . 벡터 , 행렬 , 배열 ,
  데이터 프레임 등 의 서로 다른 구조의 데이터를 하나로 묶을 수 있는 자료구조이다
  R에서는 통계 분석 결과가 리스트 구조로 제시되 는 경우가 많으며 서로 다른 구조의 다수의
  데이터 객체를 개별로 따로 따로 관리하는 것보다는 , 이것들을 리스트라는 한 바구니에 가지
  런히 정리해서 모아놓으면 관리하기 편하다
  list() 함수로 리스트를 생성하고 , [, [[, $ 을 통해 부분집합을 뽑아낸다

  **[: 리스트가 포함한 하위 리스트를 뽑아낸다
  [[, $: 하위 리스트가 포함한 원소를 추출하고 , 계층구조 수준을 한단계 제거한다**

![image-20200324094742305](C:\Users\seouz\AppData\Roaming\Typora\typora-user-images\image-20200324094742305.png)

데이터셋이 중요한 이유는 자료를 분석하기 위해서 다양한 형태의 개별 자료를 통합적으로 분석하기 위해서다 . 예를 들어 개인 신용분석을 위해서는 개인의 소득 , 부채 , 성별 , 학력 등등의 숫자형 , 문자형 , 요인 ( 형 등의 자료를 데이터셋에 담아야 한다 .
특히 변수와 관측값 (Variable Observation) 형식의 자료를 분석하기 위해서는 데이터프레임 (data. 을 사용한다 . 데이터프레임은 모든 변수에 대해서 관측값이 같은 길이를 갖도록 만들어 놓은 것이다

![image-20200324164719004](C:\Users\seouz\AppData\Roaming\Typora\typora-user-images\image-20200324164719004.png)

(5) R
의 데이터 입출력
[데이터 출력 함수

- print(x, ...)
  print( 출력데이터 [, 옵션들])

- cat()
  cat(…, 옵션들, ...)
  print(100)
  print(pi)
  data <- "가나다"
  print(data)
  print(data, quote=FALSE)     -> quote .......................
  v1 <- c("사과", "바나나", "포도")
  print(v1)
  print(v1, print.gap=10)
  cat(100)
  cat(100,200)
  cat(100,200,"\\n")
  cat("aaa", "bbb", "ccc", "ddd", "\\n")
  cat(v1, "\\n")
  cat(v1, sep="-", "\\n")
  print(paste("R", "은 통계분석", "전용 언어입니다."))
  cat("R", "은 통계분석", "전용 언어입니다.", "\\n")

  

- [ 지금까지 만들어진 데이터 셋과 함수 저장하기 ]

  모두 저장 :save(list=ls(), file=" all.rda") // xxx.RData 도 좋음

  rm(list=ls()); ; ls()
  읽어오기 :load("all.rda")
  한 개 저장 ::save(변수명, file="one.rda")

  [파일에서 데이터 읽어 들이기 ]]
  nums <- scan("sample_num.txt")
  words_ansi <- scan("sample_ansi.txt", **what=""**)

  

  words_utf8 <-- scan("sample_utf8.txt", what="", encoding="UTF-8")
  lines_ansi <- readLines("sample_ansi.txt")
  lines_urf8 <- readLines("sample_utf8.txt", encoding="UTF-8")
  df1 <- read.csv("CSV파일 또는 CSV를 응답하는 URL")
  df2 <- read.table("일정한 단위(공백 또는 탭등)로 구성되어 있는 텍스트 파일 또는 URL")
  **(필요에 따라서 stringsAsFactors 속성 사용)**
  write.csv(파일명), write.table(파일명)

  (6)제어문
  주어진 명령을 수행하는데 있어서 조건에 따라서 수행여부를 정하고자 하는 경우 , 필요한 만큼 반복 수행하려는 경우 모두 제어문을 사용한다 . 전자의 경우에는 조건문인 if 문을 사용하며 후자의 경우에는 반복문인 for, while, repeat 문을 사용한다. .

  제어문을 적용하여 수행하려는 명령이 여러 개이면 블록({ })로 \구성한다.

![image-20200324180540707](C:\Users\seouz\AppData\Roaming\Typora\typora-user-images\image-20200324180540707.png)

![image-20200324180550967](C:\Users\seouz\AppData\Roaming\Typora\typora-user-images\image-20200324180550967.png)

![image-20200324180559602](C:\Users\seouz\AppData\Roaming\Typora\typora-user-images\image-20200324180559602.png)

![image-20200324180612615](C:\Users\seouz\AppData\Roaming\Typora\typora-user-images\image-20200324180612615.png)

![image-20200324180621633](C:\Users\seouz\AppData\Roaming\Typora\typora-user-images\image-20200324180621633.png)

#### 예제 List, 제어문, 반복문, 함수 예제

```R
#LIST
v<-c(1,2,3)
l<-list(1,2,3) # List는 데이터를 대입할 때 포장해서 넣는다. 모두 벡터 또는 다른 값들을 저장!!
v
l # list는 바로 셈을 하라 수 없으니 unlist해서 사용할 수 있다.

v[1]
l[1] # 벡터 매트릭스 처럼 꺼내면 포장된 채로 추출한다.
## 리스트는 포장된 채로는 셈을 할 수 없다. 그래서 겹대괄호를 사용한다.
l[[1]]

lds <- list(1,2,3)  
lds
lds+100 # error
unlist(lds) # vector로 변경됨
unlist(lds) + 100
lds[1]
lds[1]+10
lds[[1]]+10

names(lds) <- LETTERS[1:3]
lds
lds[[2]] # 이름이 없으면 어쩔수 없이 이렇게 사용해야한다.
lds[["B"]]
lds$B

# 부교재에 있음
a<-list(
  a = 1:3,
  b = "a string",
  c = pi,
  d = list(-1,-5)
)

a[1]
a[[1]] # a[["a"]]
a$a
a[[1]][1]
a$a[1]
a[1]+1
a[[1]]+1
a[[1]][2] <- 100
new_a <- unlist(a[1]) # 자동으로 예쁘게 list가 붙음
a[1]; new_a
names(a) <- NULL
names(new_a) <- NULL



ls()
length(ls())
# varience will save in "all.rda" of rexam
# 지금까지 만든 모든 객체를 이미지로 저장
save(list=ls(),file="all.rda")  # **********
rm(list=ls())
ls()
load("all.rda") # **********
ls()

getwd()
setwd("C:/Oliver/Rstudy")
#read file data
nums <- scan("data/sample_num.txt") # 숫자에 특화되어있다!!
# word 단위로 what에다가 null 문자를 주면 character 벡터를 읽는다!!
word_ansi <- scan("data/sample_ansi.txt",what="")
words_utf8 <- scan("data/sample_utf8.txt", what="",encoding="UTF-8")
words_utf8_new <- scan("data/sample_utf8.txt", what="")
lines_ansi <- readLines("data/sample_ansi.txt") # 주어진 문서를 행단위로 읽어서 벡터로 리턴 # UTF-8 문서를 가져오면 무조건 깨진다.
lines_utf8 <- readLines("data/sample_utf8.txt",encoding="UTF-8") # UTF-8은 반드시 대문자로 주어야한다.
# 각각의 컬럼을 정의할 때 separate 문자를 지정할 수 있다. 따로 지정하지 않으면 blank 문자이다.
# read.csv는 무조건 ,으로 
df2 <- read.table("data/product_click.log")
str(df2)
head(df2)
summary(df2$V2)

?print
for(data in month.name) 
  print(data)

for(data in month.name) 
  cat(data,"\n")

sum <- 0
for(i in 5:15){
  if(i%%10==0){
    break;
  }
  sum <- sum + i
  print(paste(i,":",sum))
  # cat(i,":",sum,"\n") # cat은 인덱스를 출력 안함
}


sum <-0
for(i in 5:15){
  if(i%%10==0){
    next;  #continue
  }
  sum <- sum + i
  print(paste(i,":",sum))
}

sumNumber <- 0
while(sumNumber <= 20) { 
  i <- sample(1:5, 1) 
  sumNumber <-sumNumber+i; 
  cat(sumNumber,"\n")
}

repeat {
  cat("ㅋㅋㅋ\n")
}

sumNumber <- 0
repeat { 
  i <- sample(1:5, 1) 
  sumNumber <-sumNumber+i; 
  cat(sumNumber,"\n")
  if(sumNumber > 20)
    break;
}

#제어문
#if else
randomNum <-sample(1:10,1)
if(randomNum>5){
  cat(randomNum,":5보다 크군요","\n")
}else{
  cat(randomNum,":5보다 작거나 같군요","\n")
}

if(randomNum%%2 == 1){
  cat(randomNum,";홀수\n")
}else{
  cat(randomNum,";짝수","\n")
}

score <- sample(0:100, 1)  # 0~100 숫자 한 개를 무작위로 뽑아서
if (score >=90){
  cat(score,"는 A등급입니다","\n")
}else if (score >=80){
  cat(score,"는 B등급입니다","\n")
}else if (score >=70){
  cat(score,"는 C등급입니다","\n")
}else if (score >=60){
  cat(score,"는 D등급입니다","\n")
}else {
  cat(score,"는 F등급입니다","\n")
}

#for문
#for 실습
for(data in month.name) 
  print(data)
for(data in month.name)print(data);print("ㅋㅋ")
for(data in month.name){print(data);print("ㅋㅋ")}

for(n in 1:5)
  cat("hello?","\n")

for(i in 1:5){
  for(j in 1:5){
    cat("i=",i,"j=",j,"\n")
  }
}
# 구구단
for(dan in 1:9){
  for(num in 1:9){
    cat(dan,"x",num,"=",dan*num,"\t") # \n : 개행문자, \t : 탭문자
  }
  cat("\n")
}


bb <- F
for(i in 1:9){
  for(j in 1:9){
    if(i*j>30){
      bb<-T
      break
    } 
    cat(i,"*",j,"=",i*j,"\t")
  }
  cat("\n")
  if(bb) #bb가 TRUE이면
    break
}

#while문
i<-1
while(i <= 10){
  cat(i,"\n")
  i <- i+1
}
cat("종료 후 :",i,"\n")

i<-1
while (i<=10) {
  cat(i,"\n")
}

i<-1
while (i<=10) {
  cat(i,"\n")
  i<-i+2
}

i<-1
while (i<=10) {
  cat(i,"\n")
  i<-i+1
}

#switch 문을 대신하는 함수
month <- sample(1:12,1)
month <- paste(month,"월",sep="") # "3월"  "3 월"
result <- switch(EXPR=month, # character type
                 "12월"=,"1월"=,"2월"="겨울", # 12, 1, 2 겨울
                 "3월"=,"4월"=,"5월"="봄", # 3, 4, 5 봄
                 "6월"=,"7월"=,"8월"="여름", # 6, 7, 8 여름
                 "가을") # 나머지는 가을
cat(month,"은 ",result,"입니다\n",sep="")

num <- sample(1:10,1)
num
# numeric 타입이니까 비교값은 올 수 없고 수치 값만 올수 있다.
switch(EXPR = num,"A","B","C","D") 

for(num in 1:10){
  cat(num,":",switch(EXPR = num,"A","B","C","D"),"\n")
}

# switch 구문에서 character값은 그 외 모든 것을 사용할 수 있지만
# numeric타입은 사용할 수 없다.
for(num in 1:10){
  num <- as.character(num) # 강제 형변환
  cat(num,":",switch(EXPR = num,
                     "7"="A","8"="B","9"="C","10"="D","ㅋ"),"\n") #  그 외의 모든 것은 ㅋ으로
}

# 함수 정의와 활용 ########################################################
func1 <- function() {
  xx <- 10   # 지역변수
  yy <- 20
  return(xx*yy)
}
func1()

result <- func1()
result
xx  # local 변수라서 오류발생


func2 <- function(x,y) {
  xx <- x
  yy <- y
  return(sum(xx, yy))
}

func2()
func2(5,6) # 식 : 연산식, 호출식, 변수, 리터럴

func3 <- function(x,y) {
  #x3 <- x+1
  #y3 <- y+1
  x4 <- func2(x+1, y+1)  # 값(식) : 변수, 리터럴, 연산식, 호출식
  return(x4)
}

func3(9, 19)  # 30

func4 <- function(x=100, y=200, z) {
  return(x+y+z)
}
func4()
func4(10,20,30)
func4(x=1,y=2,z=3)
func4(y=11,z=22,x=33)
func4(z=1000)


# 쉬트에 있는 함수 코드
f1 <- function() print("TEST")
f1()
r <- f1()
r
f2 <- function(num) {print("TEST"); print(num) }
f2(100)
f2()
f3<- function (p="R") print(p)
f3()
f3(p="PYTHON")
f3("java")
f4<- function (p1="ㅋㅋㅋ",p2) for(i in 1:p2) print(p1)
f4(p1="abc", p2=3)
f4("abc", 3) 
f4(5) 
f4(p2=5) 
f5<- function(...) { print("TEST"); data <- c(...); print(length(data))}
f5(10, 20, 30)
f5("abc", T, 10, 20)
f6<- function(...) {
  print("수행시작")
  data <- c(...)
  for(item in data) {
    print(item)
  }
  return(length(data))
}
f6()
f6(10)
f6(10,20)
f6(10,20,30)
f6(10,'abc', T, F)

f7<- function(...) {
  data <- c(...)
  sum <- 0;
  for(item in data) {
    if(is.numeric(item))
      sum <- sum + item
    else
      print(item)
  }
  return(sum)
}
f7(10,20,30)
f7(10,20,'test', 30,40)

f8<- function(...) {
  data <- list(...)
  sum <- 0;
  for(item in data) {
    if(is.numeric(item))
      sum <- sum + item
    else
      print(item)
  }
  return(sum)
}

f8(10,20,30)
f8(10,20,"test", 30,40)
```

