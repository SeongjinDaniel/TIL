# Password 암호화

![image](https://user-images.githubusercontent.com/55625864/89532542-e6c43380-d82c-11ea-9ac6-8732ccf0e28f.png)

패스워드를 저장할 때 사용하는 알고리즘을 먼저 봐야 하는데 일단 패스워드는 무조건 `단방향` 암호화/해싱을 사용해야 한다.

한번 encode된 패스워드는 다시 복호화를 할 수 없도록 해야 하고(AES,RSA,DES… 등의 양방향 암호화를 사용하면 안된다는 뜻이다) 이를 비교하는 로직만 같은지 아닌지만 판단할 수 있게 만들어야 한다.

이를 지키지 않을 경우 최악은 DB에 저장된 유저의 패스워드가 다 복호화 되어 개인정보가 유출이 된다. 혹은 결제와 관련된 경우 직접적인 타격을 받게될 수도 있다.



---

---



Spring Security에서 지원하는 몇 가지 인코딩 메커니즘이 있으며 이 기사에서는 일반적으로 사용 가능한 최상의 솔루션 인 **BCrypt를** 사용할 것이다.

*MD5PasswordEncoder* 및 *ShaPasswordEncoder* 와 같은 대부분의 다른 메커니즘 은 더 약한 알고리즘을 사용하므로 더 이상 사용되지 않는다.

Spring의 기본 PasswordEncoder는 bcrypt를 권장하는 것으로 보인다.



---

---



[네이버 D2 기술블로그 발췌]

보안 시스템의 여러 부분 중, 패스워드를 저장할 때 사용되는 해시 함수(hash function)의 개념을 설명하고 대부분의 웹 사이트에서 사용하고 있는 암호화 알고리즘의 안정성을 검토한다. 그리고 어떤 암호화 알고리즘을 사용해야 안전한지 설명한다.



## 단방향 해시 함수

보통 프로그래머는 아래의 두 가지 중 한 가지로 사용자의 패스워드를 저장한다.

- 단순 텍스트(plain text)
- 단방향 해시 함수(one-way hash function)의 다이제스트(digest)

단순 텍스트로 패스워드를 저장하는 것은 범죄를 저지르는 것이나 다름없다. 아직도 이런 방법을 사용하고 있다면 지금 당장 변경해야 한다.

단방향 해시 함수는 수학적인 연산을 통해 원본 메시지를 변환하여 암호화된 메시지인 다이제스트를 생성한다. 원본 메시지를 알면 암호화된 메시지를 구하기는 쉽지만 암호화된 메시지로는 원본 메시지를 구할 수 없어야 하며 이를 '단방향성'이라고 한다.

예를 들어 사용자의 패스워드가 "**hunter2**"라면 이 문자열을 흔히 사용하는 해시 알고리즘인 SHA-256으로 인코딩하여 아래와 같은 값을 얻을 수 있다.

```
f52fbd32b2b3b86ff88ef6c490628285f482af15ddcb29541f94bcf526a3f6c7
```

위의 값을 저장하면 사용자의 패스워드를 직접 저장하는 위험을 피할 수 있다. 그리고 사용자가 로그인할 때 패스워드를 입력하면, 이를 해시한 값을 저장된 값과 비교하여 일치 여부를 확인할 수 있다.

대부분의 해시 함수는 입력 값의 일부가 변경되었을 때 다이제스트가 완전히 달라지도록 설계되어 있다. "**hunter3**"라는 값의 SHA-256 다이제스트는 아래와 같으며 위의 "hunter2"와는 완전히 달라진 것을 확인할 수 있다.

```
fb8c2e2b85ca81eb4350199faddd983cb26af3064614e737ea9f479621cfa57a
```

이 특징을 avalanche 효과라고 하며, 사용자의 원본 패스워드를 추론하기 어렵게 만드는 중요한 요소이다. 그러나 이것만으로는 패스워드 보안이 충분히 안전하다고 말할 수 없다.



## 단방향 해시 함수의 문제점

대부분의 웹 사이트에서는 SHA-256과 같은 해시 함수를 사용해 패스워드를 암호화해 저장하고 값을 비교하는 것만으로 충분한 암호화 메커니즘을 적용했다고 생각하지만, 실제로는 다음과 같은 두 가지 문제점이 있다.

### 인식 가능성(recognizability)

동일한 메시지가 언제나 동일한 다이제스트를 갖는다면, 공격자가 전처리(pre-computing)된 다이제스트를 가능한 한 많이 확보한 다음 이를 탈취한 다이제스트와 비교해 원본 메시지를 찾아내거나 동일한 효과의 메시지를 찾을 수 있다. 이와 같은 다이제스트 목록을 레인보우 테이블(rainbow table)이라 하고, 이와 같은 공격 방식을 레인보우 공격(rainbow attack)이라 한다. 게다가 다른 사용자의 패스워드가 같으면 다이제스트도 같으므로 한꺼번에 모두 정보가 탈취될 수 있다.

### 속도(speed)

해시 함수는 암호학에서 널리 사용되지만 원래 패스워드를 저장하기 위해서 설계된 것이 아니라 짧은 시간에 데이터를 검색하기 위해 설계된 것이다. 바로 여기에서 문제가 발생한다. 해시 함수의 빠른 처리 속도로 인해 공격자는 매우 빠른 속도로 임의의 문자열의 다이제스트와 해킹할 대상의 다이제스트를 비교할 수 있다(MD5를 사용한 경우 일반적인 장비를 이용하여 1초당 56억 개의 다이제스트를 대입할 수 있다).

이런 방식으로 패스워드를 추측하면 패스워드가 충분히 길거나 복잡하지 않은 경우에는 그리 긴 시간이 걸리지 않는다. 그리고 대부분 사용자의 패스워드는 길거나 복잡하지 않을 뿐 아니라, 동일한 패스워드를 사용하는 경우도 많다.

반면 사용자는 웹 사이트에서 패스워드를 인증하는 데 걸리는 시간에는 그리 민감하지 않다. 사용자가 로그인하기 위해 아이디와 패스워드를 입력하고 확인 버튼을 누르는 과정에 10초가 걸린다고 가정했을 때, 다이제스트를 생성하는 데 0.1초 대신 1초가 소요된다고 해서 크게 신경 쓰는 사람은 많지 않다. 즉, 해시 함수의 빠른 처리 속도는 사용자들보다 공격자들에게 더 큰 편의성을 제공하게 된다.



## 단방향 해시 함수 보완하기

### 솔팅(salting)

솔트(salt)는 단방향 해시 함수에서 다이제스트를 생성할 때 추가되는 바이트 단위의 임의의 문자열이다. 그리고 이 원본 메시지에 문자열을 추가하여 다이제스를 생성하는 것을 솔팅(salting)이라 한다. 예를 들어 다음과 같이 "redfl0wer"에 솔트인 "8zff4fgflgfd93fgdl4fgdgf4mlf45p1"를 추가해 다이제스트를 생성할 수 있다.

![image](https://user-images.githubusercontent.com/55625864/89598411-b8c80900-d897-11ea-9e02-01c4c1cffce0.png)

이 방법을 사용하면, 공격자가 "redfl0wer"의 다이제스트를 알아내더라도 솔팅된 다이제스트를 대상으로 패스워드 일치 여부를 확인하기 어렵다. 또한 사용자별로 다른 솔트를 사용한다면 동일한 패스워드를 사용하는 사용자의 다이제스트가 다르게 생성되어 인식 가능성 문제가 크게 개선된다.

솔트와 패스워드의 다이제스트를 데이터베이스에 저장하고, 사용자가 로그인할 때 입력한 패스워드를 해시하여 일치 여부를 확인할 수 있다. 이 방법을 사용할 때에는 모든 패스워드가 고유의 솔트를 갖고 솔트의 길이는 32바이트 이상이어야 솔트와 다이제스트를 추측하기 어렵다.



### 키 스트레칭(key stretching)

입력한 패스워드의 다이제스트를 생성하고, 생성된 다이제스트를 입력 값으로 하여 다이제스트를 생성하고, 또 이를 반복하는 방법으로 다이제스트를 생성할 수도 있다. 이렇게 하면 입력한 패스워드를 동일한 횟수만큼 해시해야만 입력한 패스워드의 일치 여부를 확인할 수 있다. 이것이 기본적인 키 스트레칭 과정이다.

잘 설계된 패스워드 저장 시스템에서는 하나의 다이제스트를 생성할 때 어느 정도(일반적인 장비에서 0.2초 이상)의 시간이 소요되게 설정한다. 이는 억지 기법 공격(brute-force attack)으로 패스워드를 추측하는 데 많은 시간이 소요되도록 하기 위한 것이다.

최근에는 일반적인 장비로 1초에 50억 개 이상의 다이제스트를 비교할 수 있지만, 키 스트레칭을 적용하여 동일한 장비에서 1초에 5번 정도만 비교할 수 있게 한다. GPU(Graphics Processing Unit)를 사용하더라도 수백에서 수천 번 정도만 비교할 수 있다. 50억 번과는 비교할 수도 없을 정도로 적은 횟수다. 앞으로 컴퓨터 성능이 더 향상되면 몇 번의 반복을 추가하여 보완할 수 있다.

다음 그림은 솔트를 추가한 패스워드에 여러 단계의 해시 함수를 적용하여 다이제스트를 생성하는 과정을 나타낸 것이다.

![image](https://user-images.githubusercontent.com/55625864/89599017-4c4e0980-d899-11ea-886f-f7bd01dec9da.png)

앞에서 설명한 바와 같이 솔팅과 키 스트레칭으로 구성된 암호화 시스템을 구현하려고 한다면 이미 검증된 암호화 시스템을 사용할 것을 권장한다. 널리 알려진 검증된 시스템을 사용하면, 암호화 시스템을 잘못 구현해서 발생하는 위험을 피할 수 있다.



이에 비해 자신만의 암호화 시스템을 구현하는 것은 매우 위험하다. 이 경우 취약점을 확인하기 어렵고, 대부분의 경우 구현된 암호화 시스템을 점검하고 확인하는 사람은 암호화 시스템을 구현한 당사자 한 명이다. 만약 구현한 암호화 시스템에 취약점이 있다면, 많은 사람들이 사용할수록 그만큼 많은 사람들이 피해를 입게 된다. 이런 취약점이 내포된 시스템은 여러 차례 발견되었고, 이와 같은 시스템을 사용한 프로그램들이 여러 해 동안 BSD나 Linux에서 사용되어 왔다.



---

---



## 자바 SHA-256 암호화

**MD5와 SHA-256은 단뱡향 암호화로 비밀번호를 암호화 하거나 데이터 전송등에서 무결성을 체크하는데 사용됩니다. MD5는 128bit로 서로 다른 값에 같은 해시가 발생하는 충돌이 확인 되었고, 빠르게 해시가 가능하므로 비밀번호를 만드는데는 안전하지 않다고합니다. 이제는 SHA-256을 사용하기는 권장하고 있습니다.**



**SHA-256은 현재가장 많은 분야에서 채택하여 사용되고 있는 암호 방식이다. 출력 속도가 빠르다는 장점을 갖고 있다. 또한 단방향성의 성질을 띄고 있는 암호화 방법으로 복호화가 불가능하다. SHA-384, 512, SHA-3보다는 유효 보호 수준이 낮을 지는 모르지만, 현재까지 안정성 문제에서도 큰 단점이 발견되지 않았고, 속도가 빠르기 때문에 인증서, 블록체인 등 많이 사용되고있으며, SHA-2라고 하면 SHA-256이라고 말할 정도로 상용화가 잘 되어있다.**



*** 단방향 알고리즘**

단방향(One-Way) 암호화는 평문을 암호화했을 때 다시 평문으로 복호화할 수 없는 암호화이다. 대표적으로 많이 사용되는 알고리즘이 SHA-256 암호화 알고리즘이다. SHA-256은 임의의 길이 메시지를 256 비트(bits)의 축약된 메시지로 만들어내는 해시 알고리즘이다. 데이터의 수정과 변경을 검출 할 수 있으나 인증은 불가능하다. 인증에 사용하기 위해 메시지 인증 코드와 디지털 서명이 요구된다.



MD5이던 SHA-256 이던 적절한 길이의 salt와 bcrypt, scrypt 또는 pbkdf2와 같은 느린 알고리즘을 적용하여 무작위 대입 공격에 대한 대비를 해야만 안전한 비밀번호를 만들 수 있습니다.



**1. MD5 해시**

\- MessageDigest객체 생성시 알고리즘을 "MD5"로 해서 만듭니다. 해시된 데이터는 바이트 배열의 바이너리 데이터이므로 16진수 문자열로 변환해 줍니다.



```java
public static String md5(String msg) throws NoSuchAlgorithmException {

    MessageDigest md = MessageDigest.getInstance("MD5");
    md.update(msg.getBytes());
    return CryptoUtil.byteToHexString(md.digest());
}
```



**2. SHA-256으로 해시**

\- MessageDigest객체 생성시 알고리즘을 "SHA-256"으로 해서 만듭니다. 해시된 데이터는 바이트 배열의 바이너리 데이터이므로 16진수 문자열로 변환해 줍니다.



```java
public static String sha256(String msg)  throws NoSuchAlgorithmException {

    MessageDigest md = MessageDigest.getInstance("SHA-256");
    md.update(msg.getBytes());
    return CryptoUtil.byteToHexString(md.digest());
}
```



**3. 바이트 배열을 HEX 문자열로 변환**

\- 바이트 배열을 16진수 문자열로 변환합니다.

```java
public static String byteToHexString(byte[] data) {

    StringBuilder sb = new StringBuilder();
    for(byte b : data) {
        sb.append(Integer.toString((b & 0xff) + 0x100, 16).substring(1));
    }
    return sb.toString();
}
```



**4. AES 256 으로 암호화**

\- AES 256은 키가 256bit 즉 32바이트 문자열 이어야 합니다.

\- 이 예제에서는 임의의 길이의 키 문자열을 받아서 랜덤 salt 를 첨가해서 해시하여 256bit 키를 생성합니다.

\- 암호화 모드는 CBC를 사용하고, 길이를 일정하게 하는데 PKCS5 패딩을 사용합니다.

\- salt를 사용하므로 동일한 값을 암호화 하더라도 암호된 값이 동일하지 않습니다.

\- 결과값에는 salt와 iv값을 추가하여 Base64로 엔코딩 하여 반환합니다.

\- Java 8에는 Base64 기능이 포함되어 있지만, 그 이전 버전의 JDK를 사용한다면 apache common codec 라이브러리 등을 사용하여 Base64 엔코딩 기능을 사용할 수 있습니다.



---

---



**평문(Plaintext)**

해독 가능한 형태의 메시지



**암호문(Ciphertext)**
해독 불가능한 형태의 메시지



**암호화(Encryption)**

평문을 암호문으로 변환하는 과정



**복호화(Decryption)**

암호문을 편문으로 변환하는 과정



---

---



# [암호 알고리즘](https://namu.wiki/w/암호 알고리즘)

1. 개요

   컴퓨터가 발달하면서 이전에는 군용이나 중대한 사업용으로만 쓰이던 암호가 일상 생활에도 널리 활용되게 되었다. 단순한 개인 게시판을 시작으로 대형 DBMS까지 다양한 분야에서 암호학이 실제로 쓰이며, 이러한 암호의 보급화는 전자상거래가 시작되는 데 결정적인 역할을 하기도 했다. 암호는 개인정보 보호와 악의적 공격자의 공격으로 인하여 데이터가 누출되었을 때 중요한 자료들을 바로 가져갈 수 없도록 처리하는 역할을 한다.

2. 암호의 분류 방법

   암호는 크게 대칭형 암호와 비대칭형 암호의 2가지로 나눌 수 있으며, 암호화에 사용하는 키 값과 복호화에 사용하는 키 값이 같은지 다른지를 기준으로 구분한다. 암호화할 때 사용한 키로 복호화를 할 수 있으면 **대칭형 암호**, 암호화 키와 복호화 키를 따로 구분하면 **비대칭형 암호**다. 통상적으로 **대칭형 암호는 비공개키 암호에 사용**되며 **비대칭형은 공개키 암호에 사용**된다.

   대칭형 암호 중에는 블럭 암호와 스트림 암호가 있다. 전자는 일정 비트 수(단위, 또는 블럭)를 암호화하는 방식이며, 후자는 연속적인 데이터를 암호화하는 방식이다.

   - 대칭형 암호

     상술했듯 암호화할 때 사용하는 키와 복호화할 때 사용하는 키가 동일한 암호화 기법이다. 현재 사용되는 대칭형 암호화 알고리즘은 주로 파이스텔 네트워크(Feistel Network) / S-Box를 통하여 블럭 암호로 만들어졌지만 AES처럼 파이스텔 네트워크를 사용하지 않는 알고리즘도 있다. 이쪽은 라인달(Rijndael) 알고리즘이라는 비교적 새로운 알고리즘을 적용하고 있다.

     현재 가장 보편적으로 쓰이는 암호화 방식은 현 미국 표준 방식인 [AES](https://namu.wiki/w/고급 암호화 표준). 128~256비트 키를 적용할수 있어 보안성이 뛰어나며 공개된 알고리즘이라 누구나 사용할 수 있다. 그전에는 DES(Data Encryption Standard)라는 알고리즘이 1975년부터 사용되고 있었으나 너무 오래되어 취약점이 발견됨에 따라[[1\]](https://namu.wiki/w/암호 알고리즘#fn-1) 이를 대체하기 위해 등장한 것이 바로 AES이다.

     그 외에는 RC4, Twofish, Serpent, Blowfish, CAST5, 3DES, IDEA 등의 암호화 알고리즘이 존재하며 국내에서 개발된 [SEED](https://namu.wiki/w/SEED)와 [ARIA](https://namu.wiki/w/아리아#s-2)라는 알고리즘도 있다. AES는 현재 일반인들이 쉽게 접근할 수 있는 암호화 방식들 중에서 충분히 안전성이 있다고 알려진 암호로 암호화 키와 복호화 키가 동일하다. 즉, `ABCDE`라는 문자열을 `QWERTY`라는 키로 암호화했으면 복호화도 반드시 `QWERTY`로 해야 한다.(실제 키는 128비트 또는 256비트와 같이 알고리즘에서 요구하는 길이를 사용하여야 하기 때문에 16바이트 또는 32바이트가 되어야 한다.)

     대칭형 암호를 공격하는 방식에는 Known-PlainText, Chosen-PlainText, Differential, Linear 등의 방식이 있으며, AES의 경우 이러한 방식을 통한 알고리즘의 취약점 공격에 대해서는 아직 알려진 게 없음으로 안전하다고 알려져 있다. 하지만 2005년 DJ Bernstein의 논문에 따르면, SBOX를 읽어들이는 시간에 따라 서버와 통신시간에서 차이가 발생할 수 있어서 취약점이 발생한다고 지적하고 있다. ~~사실 이 방식은 대부분의 대칭형 암호에 대해서 취약해서 딱히 AES의 잘못이라고 보기 어렵다.~~

   - 비대칭형 암호

     대칭형 암호는 훌륭한 암호화 방식이기는 하지만 결정적인 문제가 존재한다. 바로 '키 배송'에 관한 문제로, 어떻게든 송신 측에서는 수신 측에 암호 키를 전달해야만 하고, 이 키가 배송 과정에서 털리면 아무리 뛰어난 암호화 알고리즘을 사용했더라도 속절없이 평문이 털리게 된다. 안전하게 평문을 전달하기 위해 만든 것이 암호문인데, 정작 키는 안전하게 전달할 방법이 없는 것. 이 키 배송에 대한 방법은 여러 가지 방법이 연구되었지만 발상의 전환으로 키 배송 문제를 해결한 방식이 비대칭형 암호이다.

     비대칭형 암호는 이름 그대로 암호화 키와 복호화 키가 다르다. 암호화를 하면 하나의 키 쌍이 생기고 이 두 개의 키는 수학적으로 밀접한 관계를 가지고 있다. 두 개의 키를 각각 키 A, 키 B라고 했을 때 키 A로 암호화한 암호문은 키 B로만 복호화할 수 있다. 따라서 이 중 하나의 키(B)만 비밀로 보호하고(이를 '비밀키', '개인키'라고 한다) 다른 하나의 키(A)는 공중에게 공개해도 관계가 없다(이를 '공개키'라고 부른다). 이렇게 둘 중 하나의 키는 반드시 공개되어야 통상적인 사용이 가능하므로 공개키 암호라고도 불린다. 공개키로 암호화한 암호문은 어차피 개인키를 가진 사람만이 풀어볼 수 있으므로 상호간에 공개키만 교환하고 상대의 공개키로 암호화를 해서 데이터를 교환하면 상대는 자신의 개인키로 복호화를 한다. 따라서 키 배송 문제는 근본적으로 발생하지 않는 것.

     굉장히 참신한 아이디어기는 한데 비대칭형 암호는 암/복호화가 대칭형 암호에 비해 현저하게 느리다는 문제점이 있다. 따라서 현실적으로는 비대칭형 암호를 이용해서 대칭형 암호의 키를 배송하고 실제 암호문은 대칭형 암호를 사용하는 식으로 상호보완적으로 이용하는 것이 일반적이다. 그리고 비대칭형 암호라고 약점이 없는 것은 아니어서 [중간자 공격](https://namu.wiki/w/중간자 공격)(MITM : Man In The Middle Attack)에는 취약하다. 해커가 중간에서 통신을 가로채어 수신자에게는 송신자인 척하고 송신자에게는 수신자인 척 해서 양쪽의 공개키와 실제 암호화에 사용되는 대칭키를 모두 얻어내는 기법. 참고로 이 중간자 공격을 미리 차단하기 위해서 사이트 인증서라는 것이 존재한다.

     그리고 아직까지는 효율적인 알고리즘이 없어서 불가능하지만, 공개키만을 수집해서 비밀키 없이 수학적인 관계가 있는 임의의 키를 잔뜩 생성해서 다 때려 꽂아넣는 효율적인 알고리즘이 개발된다면, 비대칭형 암호는 대칭형 암호보다 못한 물건이, 아니, 그냥 숭숭 뚫려버릴 가능성이 농후하다. 물론 아직까지는 해시 함수의 역함수나, 큰 소수를 효율적으로 구하는 알고리즘은 없으니 상관 없다.

     대표적인 비대칭형 암호에는 [Diffie-Hellman 키 교환](https://namu.wiki/w/디피-헬만 키 교환), DSS, ElGamal, ECC, [RSA 암호화](https://namu.wiki/w/RSA 암호화) 등이 있다.

   - 단방향 암호

     평문을 암호문으로 암호화하는 것은 가능하지만 암호문을 평문으로 복호화하는 것은 불가능한(!) 암호화 기법. 기본적으로 동일한 평문은 동일한 암호문으로 암호화되지만 이를 바탕으로 평문을 복원할 수는 없다. 얼핏 생각하면 뭐 이딴 게 다 암호화냐! 라고 할 수도 있겠지만 실제로는 복호화하지 않아도 상관없는 정보가 있기 마련이다. 예를 들면 패스워드는 양방향 암호로 저장하는 것보다 단방향 암호로 저장하는 것이 안전하다. 암호화된 패스워드 목록이 털린다고 해도 이를 가지고 원래의 패스워드를 복원할 수 없고, 패스워드 자체를 검증할 때는 입력받은 값을 암호화해서 암호화한 값끼리 비교하면 땡이기 때문.

     주로 [해시](https://namu.wiki/w/해시) 기법을 사용하며 최소한 [SHA-256](https://namu.wiki/w/SHA), 가능하면 SHA-3를 쓰는 것이 좋다. 나머지는 취약점이 발견된 상태며, **특히 [MD5](https://namu.wiki/w/MD5)는 단시간 내에 충돌값을 찾아낼 수 있는 지경에 이르렀다.**[[2\]](https://namu.wiki/w/암호 알고리즘#fn-2) 패스워드 암호화에 [아직도 MD-5를 사용하는 사이트](https://namu.wiki/w/뽐뿌 개인정보 해킹 사건)가 있거든 **당장 탈퇴하라**고 얘기할 정도. ~~그걸 가입자 입장에서 알 방법이 없다는 게 함정~~

     MD5가 위험하다는 것을 쉽게 예를 들어 설명하자면, 어떤 평문을 해시화했을 때 `ABCD`가 나온다면, `ABCD`라는 해시값을 반환하는 여러 개의 평문을 예상보다 쉽게 찾을 수 있다는 의미이다. 이것이 문제가 되는 것은 MD5는 주로 파일의 무결성 검사를 위해 사용하기 때문이다. 공격 코드를 포함하지만 원래 MD5 해시값과 같은 바이너리를 비교적 손쉽게 만들 수 있다는 뜻이다. 물론 아직까지는 엄청난 연산이 필요하지만, 제곱의 기하급수적 증가를 생각해 보면 10비트만 줄여도 계산량은 210분의 1로 줄어든다! 쉽게 말하면 100만 년이 **3906년**으로 줄어드는 것이다. 이런 문제를 줄이기 위해 SHA-3은 스폰지 펑션, 즉, 원문의 길이에 따라 해시값의 길이가 예측 불가능하게 바뀌는 함수를 내장하고 있다.

3. 공격 방법

   사실 암호는 보안의 시작이자 끝이다. 즉, 악의적인 공격자는 암호를 해독하려 하고 그것을 지키려는 사람은 악의적 사용자를 배제하고 올바른 정보가 있을 경우에만 올바른 값을 돌려주려 노력한다. 즉, 물고 물리는 전쟁이다. 이러한 전쟁의 승자는 거의 대부분 악의적 사용자로 그 이유는 참으로 단순하게도 전수조사(...)라는 극악의 카드가 있었기 때문이다. 전수조사(Brute Force Attack)는 모든 사용 가능한 키 값을 일일이 대응시켜 올바른 값을 돌려주기를 기다리는 방식으로 사실 모든 암호는 무한한 시간이 주어졌다는 가정하에서 이 공격 방법을 이겨낼 수 없다. (정확히는 무한한 시간과 무한한 입력횟수를 지닐 때. 요샌 이래서 몇 번에서 몇십 번 정도 잘못된 키를 보내면 실명인증하거나 직접 서비스 회사로 본인이 찾아가기 전까지 아예 계정을 잠가버리거나, 파일이나 하드디스크 암호화라면 **파일이나 하드를 자폭시켜 버리는** 경우도 많다. "아이폰에 있는 비밀번호 20회 오류시 이 아이폰의 모든 데이터 지우기" 옵션 정도랑 비슷하다고 보면 되겠다.) 현재 사용하는 암호화 방식들은 이러한 전수조사에서 충분히 긴 시간 동안의 연산이 필요하여 실질적으로 유효한 정보를 가져갈 수 없다는 판단이 선 암호화 방식들이다. 과거에 사용된 DES[[3\]](https://namu.wiki/w/암호 알고리즘#fn-3)도 당시에는 엄청난 시간이 필요했으나 지금은 아무리 뻗대어도 몇 분이면 털릴 정도니... 즉, 시간이 가면서 컴퓨터의 연산 능력이 강해질수록 필요한 암호 키의 길이는 증가한다.

   그 외에도 [부채널 공격](https://namu.wiki/w/부채널 공격)(Side Channel Attack), Linear, Differential, Boomerang, Mod n, Related-key, Slide Rotational, Timing, XSL, Interpolation, Partitioning 등 매년 관련 논문들이 수십, 수백 편씩 나온다.

4. 암호의 종류

   - 블록 암호
     국내에서 개발된 암호 알고리즘은 [KISA](http://seed.kisa.or.kr/)에서 명세서와 소스코드를 모두 무료로 다운받아 사용할 수 있다.
     - [DES](https://namu.wiki/w/DES): 구 미국 표준. 56비트 키를 사용한다.
     - 3DES: DES를 3번 반복한다. DES로 키를 바꿔가며 암호화→복호화→암호화를 해서 키 길이를 늘리는 기법이다. 2키를 사용하는 경우 112비트, 3키를 사용하는 경우 168비트의 키 길이를 가지기 때문에 현재도 제법 안전성은 있다고는 하지만, 느리다는 문제가 있다.
     - [AES](https://namu.wiki/w/AES): 현재 표준 대칭키 암호화 기법. 128/192/256비트 키를 사용한다.
     - [SEED](https://namu.wiki/w/SEED#s-4): 대한민국의 국가 암호 표준. 128비트 키를 사용하며 2005년에 ISO/IEC 국제 표준으로 제정.
     - HIGHT: 저전력, 경량 환경에서 사용할 수 있도록 개발된 64비트 블록암호 알고 리즘. 코드 사이즈가 작고 AES보다도 속도가 빠르다. 2010년 12월 ISO/IEC 국 제표준으로 제정.
     - [ARIA](https://namu.wiki/w/아리아#s-13): SEED 이후로 나온 대한민국의 국가 암호 표준. 128/192/256비트 키를 사용한다. (AES와 동일)
     - [LEA](https://namu.wiki/w/LEA): 빅데이터, 클라우드, 모바일 등의 환경에 맞게 2013년에 국내 개발된 128비트 경량 암호 알고리즘. AES의 1.5~2배의 속도를 낼 수 있다.
     - [Blowfish](https://namu.wiki/w/블로피시)
     - [Camellia](https://namu.wiki/w/카멜리아): [일본](https://namu.wiki/w/일본)의 [미쓰비시](https://namu.wiki/w/미쓰비시)전기와 [NTT](https://namu.wiki/w/NTT)에서 개발한 알고리즘. 블록 사이즈는 128비트이며 128/192/256비트 키를 사용한다.

   - 공개키 암호
     - [RSA](https://namu.wiki/w/RSA#s-3): 공개키 암호화 기법의 사실상 표준. 매우 큰 수의 [소인수분해](https://namu.wiki/w/소인수분해)가 수학적으로 어렵다는 이론에 기반한다.
     - ECC: RSA의 키 길이가 너무 긴 결점을 보완하기 위해 타원곡선함수를 이용한 암호화 기법. 비교적 최신 기법이다.

   - 암호학적 해시 함수[[4\]](https://namu.wiki/w/암호 알고리즘#fn-4)
     - [MD5](https://namu.wiki/w/MD5): 현재는 안전하지 않다.
     - [SHA](https://namu.wiki/w/SHA)
     - [bcrypt](https://namu.wiki/w/bcrypt): 블로피시(Blowfish)라는 블록 암호 알고리즘을 해시 함수로 변형한 것이다.
     - [PBKDF2](https://namu.wiki/w/PBKDF2): 미국 정부기관에서 승인할 정도로 검증된 암호학적 해시 알고리즘이다.
     - [scrypt](https://namu.wiki/w/scrypt): PBKDF2의 강화판. [굼벵이](https://namu.wiki/w/굼벵이) 같은 해싱 속도로 유명하다(...). [[5\]](https://namu.wiki/w/암호 알고리즘#fn-5)

   - 기타
     - [ROT13](https://namu.wiki/w/ROT13)



---

---



###  참고

- https://gompangs.tistory.com/entry/Spring-Password-Encoder
- https://www.baeldung.com/spring-security-registration-password-encoding-bcrypt
- **https://d2.naver.com/helloworld/318732**
- http://www.itworld.co.kr/news/94202
- https://offbyone.tistory.com/286
- https://m.blog.naver.com/PostView.nhn?blogId=hyoun1202&logNo=220732513841&proxyReferer=https:%2F%2Fwww.google.com%2F
- https://jusungpark.tistory.com/34
- [https://namu.wiki/w/%EC%95%94%ED%98%B8%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98](https://namu.wiki/w/암호 알고리즘)
- [Salt추가](https://ohtanja.tistory.com/3)
- https://naleejang.tistory.com/218 



### 단어

1. 다이제스트

   다이제스트란, 해시 함수라는 수학적인 연산을 통해 생성된 암호화된 메시지를 의미한다. 해시 함수는 임의의 비밀번호 입력값을 문자와 숫자를 임의로 나열한 일정한 길이의 다이제스트로 전환한다. 기존에 데이터베이스에 저장된 다이제스트와 비교해서 일치하면 서비스에 로그인할 수 있다.