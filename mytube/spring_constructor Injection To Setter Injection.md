# Spring prefers constructor injection to setter injection

### Dependency Injection (의존관계 주입)

이유를 알기 위해서는 DI 에 대한 이해가 필요하다. DI 는 스프링에서만 사용되는 용어가 아니라 객체지향 프로그래밍에서는 어디에서나 통용되는 개념이다.

###### 강한 결합

객체 내부에서 다른 객체를 생성하는 것은 강한 결합도를 가지는 구조이다. A 클래스 내부에서 B 라는 객체를 직접 생성하고 있다면, B 객체를 C 객체로 바꾸고 싶은 경우에 A 클래스도 수정해야 하는 방식이기 때문에 강한 결합이다.

###### 느슨한 결합

객체를 주입 받는다는 것은 외부에서 생성된 객체를 인터페이스를 통해서 넘겨받는 것이다. 이렇게 하면 결합도를 낮출 수 있고, 런타임시에 의존관계가 결정되기 때문에 유연한 구조를 가진다.

SOLID 원칙에서 O 에 해당하는 **Open Closed Principle** 을 지키기 위해서 디자인 패턴 중 전략패턴을 사용하게 되는데, 생성자 주입을 사용하게 되면 전략패턴을 사용하게 된다.



---

수정자 주입으로 의존관계 주입은 런타임시에 할 수 있도록 낮은 결합도를 가진다.

**수정자 주입 단점**

- *NullPointerException 이 발생*
- *주입이 필요한 객체가 주입이 되지 않아도 얼마든지 객체를 생성할 수 있다는 것이 문제.*

 -> 이러한 문제를 해결할 수 있는 방법이 생성자 주입이다.

**생성자 주입의 장점**

- null 을 주입하지 않는 한 NullPointerException 은 발생하지 않는다. *NullPointerException 을 방지할 수 있다.*
- 의존관계 주입을 하지 않은 경우에는 Controller 객체를 생성할 수 없다. 즉, 의존관계에 대한 내용을 외부로 노출시킴으로써 컴파일 타임에 오류를 잡아낼 수 있다. 
- 보너스 이득은 final 을 사용할 수 있다는 것이다. final 로 선언된 레퍼런스타입 변수는 반드시 선언과 함께 초기화가 되어야 하므로 setter 주입시에는 의존관계 주입을 받을 필드에 final 을 선언할 수 없다. 
  *주입받을 필드를 final로 선언 가능하다.*
  final 의 장점은 누군가가 Controller 내부에서 service 객체를 바꿔치기 할 수 없다는 점이다.

- **스프링에서만 유용한 방법**

  - 생성자 주입을 사용하면 객체 간 순환참조를 하고 있는 경우에 스프링 애플리케이션이 구동되지 않는다.
    *컨테이너가 빈을 생성하는 시점에서 객체생성에 사이클관계가 생기기 때문이다!*

    수정자 주입을 사용하면 아주 잘 구동되고 순환참조를 하고 있는 부분에 대한 호출이 이루어질 경우 StackOverflowError 를 뱉기 때문에, 오류를 뱉을 수 밖에 없는 로직을 품고 애플리케이션이 구동되는 것이다.

  - 생성자 주입을 사용하면 단위테스트 작성하기가 좋아진다.



---

---



#### 왜 Constructor Injection을 권장하나?

**1. 단일 책임의 원칙**

생성자의 인자가 많을 경우 코드량도 많아지고, 의존관계도 많아져 단일 책임의 원칙에 위배된다. 그래서 Constructor Injection을 사용함으로써 의존관계, 복잡성을 쉽게 알수 있어 리팩토링의 단초를 제공하게 된다.

**2. 테스트 용이성**

DI 컨테이너에서 관리되는 클래스는 특정 DI 컨테이너에 의존하지 않고 POJO여야 한다. DI 컨테이너를 사용하지 않고도 인스턴스화 할 수 있고, 단위 테스트도 가능하며, 다른 DI 프레임 워크로 전환할 수도 있게 된다.

**3. Immutability**

Constructor Injection에서는 필드는 final로 선언할 수 있다. 불변 객체가 가능한데 비해 Field Injection은 final는 선언할 수 없기 때문에 객체가 변경 가능한 상태가 된다. 생성자의 주입이 개체를 만드는 유일한 방법이기 때문에 생성자 주입은 [변경 불가능한 개체](https://reflectoring.io/java-immutables) 를 만드는 데 도움이 됩니다.

**4. 순환 의존성**

Constructor Injection에서는 멤버 객체가 순환 의존성을 가질 경우 BeanCurrentlyInCreationException이 발생해서 순환 의존성을 알 수 있게 된다.

**5. 의존성 명시**

의존 객체 중 필수는 Constructor Injection을 옵션인 경우는 Setter Injection을 활용할 수 있다.



---

---



## 생성자 주입을 사용해야하는 이유는 무엇입니까?

이제 다양한 유형의 주입을 보았으므로 생성자 주입을 사용하는 몇 가지 장점을 살펴 보겠습니다.

### 모든 필수 종속성은 초기화시 사용할 수 있습니다.

생성자를 호출하여 객체를 만듭니다. 생성자가 모든 필수 종속성을 매개 변수로 예상하면 종속성이 주입되지 않으면 클래스가 인스턴스화되지 않을 것이라고 100 % 확신 할 수 있습니다.

**IoC 컨테이너는 생성자에 전달하기 전에 생성자에 제공된 모든 인수를 사용할 수 있는지 확인합니다** . 이것은 악명 높은 `NullPointerException`.

생성자 삽입은 필요한 모든 종속성이로드되었는지 확인하기 위해 모든 곳에서 별도의 비즈니스 로직을 작성할 필요가 없으므로 매우 유용합니다. 따라서 코드 복잡성이 단순화됩니다.

#### 선택적 종속성은 어떻습니까?

setter 주입을 통해 Spring은 `@Autowired(required = false)`setter 메소드 에 추가 하여 선택적 종속성을 지정할 수 있습니다 . **모든** 생성자 인수에 `required=false`적용 되므로 생성자 주입에서는 불가능합니다 .

Java의 `Optional`유형을 사용하여 생성자 주입과 함께 선택적 종속성을 제공 할 수 있습니다 .

### 코드 냄새 식별

생성자 주입은 빈이 너무 많은 다른 객체에 의존하는지 식별하는 데 도움이됩니다. 생성자가 많은 수의 인수를 가지고 있다면 이것은 우리 클래스에 너무 많은 [책임](https://reflectoring.io/single-responsibility-principle) 이 있다는 신호일 수 있습니다 . 문제의 적절한 분리를 더 잘 해결하기 위해 코드를 리팩토링하는 것에 대해 생각할 수 있습니다.

### 테스트에서 오류 방지

생성자 주입은 단위 테스트 작성을 단순화합니다. 생성자는 모든 종속성에 대해 유효한 개체를 제공하도록합니다. Mockito와 같은 모의 라이브러리를 사용하여 생성자에 전달할 수있는 모의 객체를 만들 수 있습니다.

물론 setter를 통해 모의를 전달할 수도 있지만 클래스에 새 종속성을 추가하면 테스트에서 setter를 호출하는 것을 잊고 잠재적으로 테스트에서 오류가 발생할 수 `NullPointerException`있습니다.

생성자 주입은 모든 종속성을 사용할 수있을 때만 테스트 케이스가 실행되도록합니다. 단위 테스트 (또는 그 문제에 대해 다른 곳)에서 절반의 개체를 생성하는 것은 불가능합니다.

### 불변성

생성자의 서명이 개체를 만드는 유일한 방법이기 때문에 생성자 주입은 [변경 불가능한 개체](https://reflectoring.io/java-immutables) 를 만드는 데 도움이 됩니다. 빈을 생성하면 더 이상 종속성을 변경할 수 없습니다. setter 주입을 사용하면 생성 후 종속성을 주입 할 수 있으므로, 무엇보다도 다중 스레드 환경에서 스레드로부터 안전하지 않을 수 있고 변경 가능성으로 인해 디버그하기 어려운 가변 개체로 이어질 수 있습니다.



- **참고**
  - https://yaboong.github.io/spring/2019/08/29/why-field-injection-is-bad/
  - https://www.mimul.com/blog/di-constructor-injection/
  - https://reflectoring.io/constructor-injection/