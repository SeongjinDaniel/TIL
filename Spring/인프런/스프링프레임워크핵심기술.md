# 스프링 프레임워크 핵심 기술

스프링 프레임워크(이하 스프링) 5.1 버전이 출시 되었습니다. 버전이 올라갈 수록 스프링은 다양한 프로그래밍 기법과 기능을 제공하지만 스프링의 핵심 기술은 크게 변하지 않았습니다.

즉, IoC 컨테이너, AOP 그리고 몇몇 핵심 API는 스프링을 탄탄하게 지탱하는 디딤돌과 같습니다. 따라서 스프링 핵심 기술을 이해한다면, 스프링이 제공하는 JDBC, 테스트, MVC 관련 기능 뿐 아니라, 스프링 부트와 스프링 데이터 JPA와 같은 여러 다른 스프링 프로젝트도 빠르고 정확히 이해할 수 있습니다.

구체적으로 이번 강좌에서는 스프링 IOC(Inversion Of Control) 컨테이너와 빈 그리고 스프링 AOP(Aspect Oriented Programming)에 대해 자세히 학습합니다. 또한, 스프링이 제공하는 여러 기능의 기반이 되는 Resource, Validation, 데이터 바인딩과 같은 스프링의 여러 추상 API와 Null 관련 유틸리티도 학습합니다.

이번 강좌는 IoC, AOP, PSA에 대해 들어는 봤지만, 실제 스프링으로 코딩을 해본적이 없는 분들 또는 핵심 기술에 대한 이해 없이 MVC로 웹 애플리케이션 개발만 해온 개발자 또는 학생을 대상으로 합니다. 따라서 소개와 이해를 중심으로 설명하기 때문에 매우 깊이있게 다루진 않습니다. 심화 학습을 하고 싶으신 분들께는 이번 강좌를 추천하지 않습니다.

이번 강좌는 스프링 부트를 사용하여 스프링 핵심 기술을 학습합니다. 따라서 스프링 부트 기반의 프로젝트를 사용하고 있는 개발자 또는 학생에게 유용한 스프링 강좌입니다. 스프링 부트가 제공하는 여러 기능이 스프링의 핵심기술과 어떻게 관련이 있는지 이해할 수 있습니다.

## 학습목표

- 스프링 프레임워크의 핵심 기술 Ioc, AOP, PSA를 이해합니다..
- 스프링 프레임워크 IoC 컨테이너의 다양한 기능을 사용할 수 있습니다.
- 다양한 방법으로 빈을 정의하고 의존 관계를 주입할 수 있습니다.
- 스프링 AOP를 사용하여 Aspect를 모듈화 할 수 있습니다.
- 그밖에 다양한 스프링 핵심 기술을 이해하고 또 활용할 수 있습니다.

## 학습 목차

- IoC 컨테이너와 빈
- 리소스
- Validation
- 데이터 바인딩
- SpEL
- 스프링 AOP
- Null-Safety



## 1. 강좌 및 스프링 소개

**참고: 스프링 프레임워크 레퍼런스**

https://docs.spring.io/spring/docs/current/spring-framework-reference/index.html



**스프링이란?**

https://docs.spring.io/spring/docs/current/spring-framework-reference/overview.html#overview

**"소규모 애플리케이션 또는 기업용 애플리케이션을 자바로 개발하는데 있어 유용하고 편리한 기능을 제공하는 프레임워크"**

- 스프링 프레임워크 그 자체
- 스프링 프레임워크 포함 모든 스프링 프로젝트 (스프링 부트, 스프링 데이터, 스프링 시큐리티...)
- 이 강좌에서 스프링은 "스프링 프레임워크"

**스프링의 역사**

- 2003년 등장 (개발은 이미 그 이전부터 진행됐고)
  - 등장시 Java EE 표준과 싸우는 것처럼 보였지만 실제론 JEE 스팩 구현 모음체(+알파).
  - Servlet, WebSocket, Bean Validation, JPA, Dependency Injection, ...
- 최근까지 주로 서블릿 기반 애플리케이션을 만들 때 사용해 옴.
- 스프링 5부터는 WebFlux 지원으로 서블릿 기반이 아닌 서버 애플리케이션도 개발할 수 있게 됨.

**디자인 철학**

- 모든 선택은 개발자의 몫. (예, 스프링이 특정 영속화 기술을 강요하지 않는다.)
- 다양한 관점을 지향한다. (유연성)
- 하위 호환성을 지킨다. (노력)
- API를 신중하게 설계 한다. (공들인다.)
- 높은 수준의 코드를 지향한다. (자랑)



## 2. 강사 소개

백기선

- 현재 마이크로소프트에서 개발자로 재직 중
- 아마존과 네이버에서 개발자로 일한적 있음
- [Youtube/백기선 채널]([https://www.youtube.com/c/%EB%B0%B1%EA%B8%B0%EC%84%A0](https://www.youtube.com/c/백기선)) 운영 중
- 온라인 강좌 운영 중
  - 스프링 프레임워크 입문
  - [스프링 부트 개념과 활용]([https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/](https://www.inflearn.com/course/스프링부트/))
  - [스프링 데이터 JPA]([https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-jpa/](https://www.inflearn.com/course/스프링-데이터-jpa/))

## 3. IoC 컨테이너 1부: 스프링 IoC 컨테이너와 빈

Inversion of Control: 의존 관계 주입DI(Dependency Injection)이라고도 하며, 어떤 객체가
사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주입 받아 사용하는 방법 을 말 함.
**스프링 IoC 컨테이너**

- [ BeanFactory](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html)
-  애플리케이션 컴포넌트의 중앙 저장소.
-  빈 설정 소스 로 부터 빈 정의 를 읽어들이고, 빈을 구성하고 제공 한다.

**빈**

-  스프링 IoC 컨테이너가 관리 하는 객체.(Bean들을 컨테이너에서 가져와서 사용할 수 있다.)

-  장점

  - 의존성 관리

  -  스코프
    -  싱글톤: 하나 (메모리면에서 장점, 런타임시 성능최적화에서 장점)
    -  프로포토타입: 매번 다른 객체
  - 라이프사이클 인터페이스

[ApplicationContext](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html)

- BeanFactory를 상속받음
- 메시지 소스 처리 기능 (i18n)
- 이벤트 발행 기능
- 리소스 로딩 기능
- ...

## 4. IoC 컨테이너 2부: ApplicationContext와 다양한 빈 설정 방법

![image](https://user-images.githubusercontent.com/55625864/84356133-ba11e800-abfe-11ea-95fb-529ad2b7827c.png)
**스프링 IoC 컨테이너의 역할**

- 빈 인스턴스 생성
-  의존 관계 설정
- 빈 제공

**AppcliationContext**

- ClassPathXmlApplicationContext (XML)
- AnnotationConfigApplicationContext (Java)

**빈 설정**

- 빈 명세서

- 빈에 대한 정의를 담고 있다.

  - 이름
  - 클래스
  - 스코프
  - 생성자 아규먼트 (constructor)
  - 프로퍼트 (setter)
  - ..

  **컴포넌트 스캔**

  - 설정 방법
    - XML 설정에서는 context:component-scan
    - 자바 설정에서 @ComponentScan
  - 특정 패키지 이하의 모든 클래스 중에 @Component 애노테이션을 사용한 클래스를
    빈으로 자동으로 등록 해 줌.



## 5 . IoC 컨테이너 3부: @Autowire

필요한 의존 객체의 “타입"에 해당하는 빈을 찾아 주입한다.
**@Autowired**

-  required: 기본값은 true (따라서 못 찾으면 애플리케이션 구동 실패)

**사용할 수 있는 위치**

- 생성자 (스프링 4.3 부터는 생략 가능)
- 세터
- 필드

**경우의 수**

- 해당 타입의 빈이 없는 경우
- 해당 타입의 빈이 한 개인 경우
- 해당 타입의 빈이 여러 개인 경우
  - 빈 이름으로 시도,
    - 같은 이름의 빈 찾으면 해당 빈 사용
    - 같은 이름 못 찾으면 실패

**같은 타입의 빈이 여러개 일 때**

- @Primary --> 추천!!
- 해당 타입의 빈 모두 주입 받기
- @Qualifier (빈 이름으로 주입) --> 개인적으로는 @Primary로 쓰는게 좋을듯!

**동작 원리**

- 첫시간에 잠깐 언급했던 빈 라이프사이클 기억하세요?
- [BeanPostProcessor](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html)
  - 새로 만든 빈 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스
- [AutowiredAnnotationBeanPostProcessor](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html) extends BeanPostProcessor
  - 스프링이 제공하는 @Autowired와 @Value 애노테이션 그리고 JSR-330의
    @Inject 애노테이션을 지원하는 애노테이션 처리기.

**PostConstruct**

- 빈이 다 생성 된 후  주입.



# 6. IoC 컨테이너 4부: @Component와 컴포넌트 스캔

**컨포넌트 스캔 주요 기능**

-  스캔 위치 설정 -> @SpringBootApplication은 package안에 하위 내용들은 모두 스캔함
- 필터: 어떤 애노테이션을 스캔 할지 또는 하지 않을지



**@Component**

- @Repository
- @Service
- @Controller
- @Configuration

**동작 원리**

- @ComponentScan은 스캔할 패키지와 애노테이션에 대한 정보
- 실제 스캐닝은 ConfigurationClassPostProcessor 라는 BeanFactoryPostProcessor 에
  의해 처리 됨.

**펑션을 사용한 빈 등록**

```java
public static void main(String[] args) {
    new SpringApplicationBuilder()
    .sources(Demospring51Application.class)
    .initializers((ApplicationContextInitializer<GenericApplicationContext>)
    applicationContext -> {
    	applicationContext.registerBean(MyBean.class);
    })
    .run(args);
}
```



# 7. IoC 컨테이너 5부: 빈의 스코프
**스코프**

- 싱글톤
- 프로토타입
  -  Request
  - Session
  - WebSocket
  - ...

**프로토타입 빈이 싱글톤 빈을 참조하면?**

- 아무 문제 없음.

**싱글톤 빈이 프로토타입 빈을 참조하면?**

- 프로토타입 빈이 업데이트가 안되네?
- 업데이트 하려면
  - scoped-proxy
  - Object-Provider
  - Provider (표준)

**프록시**

( https://en.wikipedia.org/wiki/Proxy_pattern )

![image](https://user-images.githubusercontent.com/55625864/84560404-a7262180-ad7e-11ea-9ca9-8b28f8dd7027.png)

**싱글톤 객체 사용시 주의할 점**

- 프로퍼티가 공유.
- ApplicationContext 초기 구동시 인스턴스 생성.





# 8. IoC 컨테이너 6부: Environment 1부. 프로파일
프로파일과 프로퍼티를 다루는 인터페이스.

ApplicationContext extends [EnvironmentCapable](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/EnvironmentCapable.html)

- getEnvironment()

**프로파일**

- 빈들의 그룹
- [Environment](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/Environment.html) 의 역할은 활성화할 프로파일 확인 및 설정

**프로파일 유즈케이스**

- 테스트 환경에서는 A라는 빈을 사용하고, 배포 환경에서는 B라는 빈을 쓰고 싶다.
- 이 빈은 모니터링 용도니까 테스트할 때는 필요가 없고 배포할 때만 등록이 되면
  좋겠다.

**프로파일 정의하기**

- 클래스에 정의
  - @Configuration @Profile(“test”)
  - @Component @Profile(“test”)
- 메소드에 정의
  - @Bean @Profile(“test”)

**프로파일 설정하기**

- -Dspring.profiles.avtive=”test,A,B,...”
- [@ActiveProfiles](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/ActiveProfiles.html) (테스트용)

**프로파일 표현식**

- ! (not)
- & (and)
- | (or)



# 9. IoC 컨테이너 6부: Environment 2부. 프로퍼티
**프로퍼티**

- 다양한 방법으로 정의할 수 있는 설정값
- [Environment](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/Environment.html) 의 역할은 프로퍼티 소스 설정 및 프로퍼티 값 가져오기

**프로퍼티에는 우선 순위가 있다.**

- StandardServletEnvironment의 우선순위

  - ServletConfig 매개변수
  - ServletContext 매개변수
  - JNDI (java:comp/env/)
  - JVM 시스템 프로퍼티 (-Dkey=”value”)
  - JVM 시스템 환경 변수 (운영 체제 환경 변수)

  @PropertySource

  - Environment를 통해 프로퍼티 추가하는 방법

  스프링 부트의 외부 설정 참고

  - 기본 프로퍼티 소스 지원 (application.properties)
  - 프로파일까지 고려한 계층형 프로퍼티 우선 순위 제공

# 10. IoC 컨테이너 7부: MessageSource
**국제화 (i18n) 기능을 제공하는 인터페이스.**

**ApplicationContext extends MessageSource**

- getMessage(String code, Object[] args, String, default, Locale, loc)
- ...

**스프링 부트를 사용한다면 별다른 설정 필요없이 messages.properties 사용할 수 있음**

- messages.properties
- messages_ko_kr.properties
- ...

**릴로딩 기능이 있는 메시지 소스 사용하기**

```java
@Bean
public MessageSource messageSource() {
    var messageSource = new ReloadableResourceBundleMessageSource();
    messageSource.setBasename("classpath:/messages");
    messageSource.setDefaultEncoding("UTF-8");
    messageSource.setCacheSeconds(3);
    return messageSource;
}
```



# 11. IoC 컨테이너 8부: ApplicationEventPublisher
이벤트 프로그래밍에 필요한 인터페이스 제공. [옵저버 패턴](https://en.wikipedia.org/wiki/Observer_pattern) 구현체.

**ApplicationContext extends [ApplicationEventPublisher](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationEventPublisher.html)**

- publishEvent(ApplicationEvent event)

**이벤트 만들기**

- ApplicationEvent 상송
- 스프링 4.2 부터는 이 클래스를 상속받지 않아도 이벤트로 사용할 수 있다.

**이벤트 발생 시키는 방법**

- ApplicationEventPublisher.publishEvent();

**이벤트 처리하는 방법**

- ApplicationListener<이벤트> 구현한 클래스 만들어서 빈으로 등록하기.
- 스프링 4.2 부터는 [@EventListener](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/event/EventListener.html) 를 사용해서 빈의 메소드에 사용할 수 있다.
- 기본적으로는 synchronized.
- 순서를 정하고 싶다면 @Order와 함께 사용.
- 비동기적으로 실행하고 싶다면 @Async와 함께 사용.

**스프링이 제공하는 기본 이벤트**

- ContextRefreshedEvent: ApplicationContext를 초기화 했더나 리프래시 했을 때 발생.
- ContextStartedEvent: ApplicationContext를 start()하여 라이프사이클 빈들이 시작
  신호를 받은 시점에 발생.
- ContextStoppedEvent: ApplicationContext를 stop()하여 라이프사이클 빈들이 정지
  신호를 받은 시점에 발생.
- ContextClosedEvent: ApplicationContext를 close()하여 싱글톤 빈 소멸되는 시점에
  발생.
- RequestHandledEvent: HTTP 요청을 처리했을 때 발생.



# 12. IoC 컨테이너 9부: ResourceLoader

**리소스를 읽어오는 기능을 제공하는 인터페이스**

**ApplicationContext extends [ResourceLoader](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/ResourceLoader.html)**

**리소스 읽어오기**

- 파일 시스템에서 읽어오기
- 클래스패스에서 읽어오기
- URL로 읽어오기
- 상대/절대 경로로 읽어오기

Resource getResource(java.lang.String location)

자세한건 다음에 이어질 [Resource](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/Resource.html) 추상화 시간에 자세히 다루겠습니다.



# 13. Resource 추상화
org.springframework.core.io.Resource
**특징**

- java.net.URL을 추상화 한 것.
- 스프링 내부에서 많이 사용하는 인터페이스.

**추상화 한 이유**

- 클래스패스 기준으로 리소스 읽어오는 기능 부재
- ServletContext를 기준으로 상대 경로로 읽어오는 기능 부재
- 새로운 핸들러를 등록하여 특별한 URL 접미사를 만들어 사용할 수는 있지만 구현이
  복잡하고 편의성 메소드가 부족하다.

[인터페이스 둘러보기](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/Resource.html)

- 상속 받은 인터페이스
- 주요 메소드
  - getInputStream()
  - exitst()
  - isOpen()
  - getDescription(): 전체 경로 포함한 파일 이름 또는 실제 URL

구현체

- UrlResource: [java.net.URL](https://docs.oracle.com/javase/7/docs/api/java/net/URL.html) 참고, 기본으로 지원하는 프로토콜 http, https, ftp, file, jar.
- ClassPathResource: 지원하는 접두어 classpath:
- FileSystemResource
- ServletContextResource: 웹 애플리케이션 루트에서 상대 경로로 리소스 찾는다.
- ...

리소스 읽어오기

- Resource의 타입은 locaion 문자열과 **ApplicationContext의 타입**에 따라 결정 된다.
  - ClassPathXmlApplicationContext -> ClassPathResource
  - FileSystemXmlApplicationContext -> FileSystemResource
  - WebApplicationContext -> ServletContextResource
- **ApplicationContext의 타입에 상관없이 리소스 타입을 강제하려면 java.net.URL**
  **접두어(+ classpath:)중 하나를 사용할 수 있다.**
  - **classpath:** me/whiteship/config.xml -> ClassPathResource
  - **file://** /some/resource/path/config.xml -> FileSystemResource



# 14. Validation 추상화
[org.springframework.validation.Validator](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/Validator.html)

애플리케이션에서 사용하는 객체 검증용 인터페이스.

특징

- 어떤한 계층과도 관계가 없다. => 모든 계층(웹, 서비스, 데이터)에서 사용해도 좋다.
- 구현체 중 하나로, JSR-303(Bean Validation 1.0)과 JSR-349(Bean Validation 1.1)을
  지원한다. ( [LocalValidatorFactoryBean](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html) )
- DataBinder에 들어가 바인딩 할 때 같이 사용되기도 한다.

**인터페이스**

- boolean supports(Class clazz): 어떤 타입의 객체를 검증할 때 사용할 것인지 결정함
- void validate(Object obj, Errors e): 실제 검증 로직을 이 안에서 구현
  - 구현할 때 ValidationUtils 사용하며 편리 함.

**스프링 부트 2.0.5 이상 버전을 사용할 때**

- **LocalValidatorFactoryBean** 빈으로 자동 등록
- JSR-380(Bean Validation 2.0.1) 구현체로 hibernate-validator 사용.
- https://beanvalidation.org/





# 15. 데이터 바인딩 추상화: PropertyEditor
[org.springframework.validation.DataBinder](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/DataBinder.html)

기술적인 관점: 프로퍼티 값을 타겟 객체에 설정하는 기능
사용자 관점: 사용자 입력값을 애플리케이션 도메인 모델에 동적으로 변환해 넣어주는 기능.
해석하자면: 입력값은 대부분 “문자열”인데, 그 값을 객체가 가지고 있는 int, long, Boolean, Date 등 심지어 Event, Book 같은 도메인 타입으로도 변환해서 넣어주는 기능.
[PropertyEditor](https://docs.oracle.com/javase/7/docs/api/java/beans/PropertyEditor.html)

- 스프링 3.0 이전까지 DataBinder가 변환 작업 사용하던 인터페이스
- 쓰레드-세이프 하지 않음 (상태 정보 저장 하고 있음, 따라서 싱글톤 빈으로 등록해서
  쓰다가는...)
- Object와 String 간의 변환만 할 수 있어, 사용 범위가 제한적 임. (그래도 그런 경우가
  대부분이기 때문에 잘 사용해 왔음. 조심해서..)

```java
public class EventPropertyEditor extends PropertyEditorSupport {
    @Override
    public String getAsText() {
    	return ((Event)getValue()).getTitle();
    }
    
    @Override
    public void setAsText(String text) throws IllegalArgumentException {
        int id = Integer.parseInt(text);
        Event event = new Event();
        event.setId(id);
        setValue(event);
    }
}
```

