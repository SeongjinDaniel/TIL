# 수영장 청소

*시간제한 1초*

### 문제

------

물이 나오는 밸브에 설치된 5가지 모양의 수도꼭지를 적절히 회전하여 수영장 청소를 손 쉽게 하려고한다. 물이 닿지 않는 곳은 사람이 청소하려한다. 최대한 사람이 청소하는데에 덜 힘들기 위해 각 수도꼭지를 적절히 회전시키려 한다. 회전은 시계방향으로 90도씩 할 수 있으며, 이외의 각도로는 회전시킬 수 없다. 5개 모양의 수도꼭지를 회전시키지 않은 상태는 다음과 같다.

![cleaning_swimmingpool1](https://alms-problem.s3.ap-northeast-2.amazonaws.com/cleaning_swimmingpool1.png)
`[그림 1]`

1번 수도꼭지는 한 방향으로만 물을 뿌릴 수 있다. 2, 3번 수도꼭지는 두 방향으로 물을 뿌릴 수 있는 점이 같으나, 2번의 경우 물이 뿌려지는 두 곳이 180도 차이가 나야되고, 3번의 경우 90도 차이가 나야하는 것이 다르다. 4번 수도꼭지의 경우 세 방향으로 물을 뿌릴 수 있고, 5번 수도꼭지의 경우 네 방향으로 물을 뿌릴 수 있다.

수도꼭지에서 나온 물줄기는 수영장 끝까지 도달한다. 만약 장애물이 있다면 장애물 앞까지만 물줄기를 쏜다. 하지만 수도꼭지는 뚫고 물을 쏜다.

예를 들어, 수영장 내부에 다음과 같이 수도꼭지 배치가 이루어졌다고 하자. 해당 상황에서 나올 수 있는 가짓수는 4가지이며, 사람이 청소해야되는 구역은 13개이다.

![cleaning_swimmingpool2](https://alms-problem.s3.ap-northeast-2.amazonaws.com/cleaning_swimmingpool2.png)
`[그림 2]`![cleaning_swimmingpool3](https://alms-problem.s3.ap-northeast-2.amazonaws.com/cleaning_swimmingpool3.png)
`[그림 3]`

수영장의 크기와 상황이 주어졌을때, 사람이 청소해야되는 구역의 최솟값을 알아내보자.

 

### 입력

------

첫 번째 줄에 테스트 케이스의 개수 T가 주어진다. 다음 줄부터 T개의 테스트 케이스에 대한 정보가 주어진다. 각각의 테스트 케이스의 첫 번째 줄에 수영장의 크기 N, M이 주어진다. 두 번째 줄부터 N개의 줄에 걸쳐 각 줄에 M개의 숫자가 공백을 통해 구분하여 주어진다. 각각의 숫자는 0부터 6까지 존재하며, 0은 아무것도 없음, 1~5는 각 숫자에 맞는 수도꼭지, 6은 장애물을 의미한다. (1 ≤ N, M ≤ 10, 1 ≤ 수도꼭지 수 ≤ 5)

 

### 출력

------

각 테스트 케이스에 대해 사람이 청소해야되는 구역의 최솟값을 출력한다. 각 테스트 케이스의 출력 양식은 "#t r"이다. t는 테스트 케이스의 번호이며, 1부터 시작한다. r은 문제에 대한 결과값을 뜻한다.

 

### 예제 입력

```
5 
5 5
0 0 0 0 0  
0 6 0 0 0 
0 0 0 5 0
0 3 0 6 0 
0 0 0 0 0
3 2 
3 0 
6 0 
2 3 
3 3 
2 5 0 
0 6 1 
3 0 0 
3 5 
6 0 6 0 6 
6 0 3 6 0
0 0 0 3 0 
5 4
0 6 0 6 
2 0 0 0 
6 0 6 0 
0 0 0 0 
0 6 0 0 
```

### 예제 출력

```
#1 13 
#2 0
#3 0
#4 4
#5 11
```

 ```c++
#include <stdio.h>
const int MAX = 15;
int n, m, k, t;
int myMap[MAX][MAX];
int dirY[4] = { -1, 0, 1, 0 };
int dirX[4] = { 0, 1, 0, -1 };
int dir[6][4] = {
	//상 우 하 좌 
	{ 0, 0, 0, 0 },
	{ 1, 0, 0, 0 },
	{ 1, 0, 1, 0 },
	{ 1, 1, 0, 0 },
	{ 1, 1, 0, 1 },
	{ 1, 1, 1, 1 }
};
int rotates[MAX];
int openingValue;
int valCnt;
int result;
void opening(int y, int x, int rotate) {
	// (y, x)에 있는 밸브를 열어서 물을 보냄.
	// 몇개의 칸에 물이 세는지를 result라는 전역변수에 저장
	int valIndex = myMap[y][x];
	int myDir[4] = { 0, };
	int myValue = 0;
	for (int i = 0; i<4; i++) myDir[i] = dir[valIndex][i];
	for (int i = 0; i<rotate; i++) {
		int temp = myDir[3];
		for (int j = 3; j >= 1; j--) myDir[j] = myDir[j - 1];
		myDir[0] = temp;
	}
	for (int i = 0; i<4; i++) {
		if (myDir[i] == 1) {
			int curY = y;
			int curX = x;
			while (true) {
				curY = curY + dirY[i];
				curX = curX + dirX[i];
				if (!(curY >= 0 && curY < n && curX >= 0 && curX < m)) break;
				if (myMap[curY][curX] == 0) {
					myMap[curY][curX] = 8;
					openingValue++;
				}
				else if (myMap[curY][curX] == 6) break;
			}
		}
	}
}
void getResult(int idx) {
	// rotates[idx]를 결정할 차례다.
	// 0 0 0 0 0 0 0 0
	// 0 0 0 0 0 0 0 1 
	if (idx >= valCnt) {
		int myValIndex = 0;
		int temp[MAX][MAX];
		openingValue = 0;
		for (int i = 0; i<n; i++) {
			for (int j = 0; j<m; j++)
				temp[i][j] = myMap[i][j];
		}
		for (int i = 0; i<n; i++) {
			for (int j = 0; j<m; j++) {
				if (myMap[i][j] >= 1 && myMap[i][j] <= 5) {
					// (i, j)에 있는 밸브를 실제로 연다.
					opening(i, j, rotates[myValIndex]);
					myValIndex++;
				}
			}
		}
		for (int i = 0; i<n; i++) {
			for (int j = 0; j<m; j++)
				myMap[i][j] = temp[i][j];
		}
		if (openingValue > result)
			result = openingValue;
	}
	else {
		for (int i = 0; i<4; i++) {
			rotates[idx] = i;
			getResult(idx + 1);
		}
	}
}
int main() {
	int t;
	scanf("%d", &t);
	for (int tt = 1; tt <= t; tt++) {
		// tt번째 테스트케이스를 처리할 차례다.
		valCnt = 0;
		result = 0;
		int zeroCnt = 0;
		scanf("%d %d", &n, &m);
		for (int i = 0; i<n; i++) {
			for (int j = 0; j<m; j++) {
				scanf("%d", &myMap[i][j]);
				if (myMap[i][j] >= 1 && myMap[i][j] <= 5)
					valCnt++;
				if (myMap[i][j] == 0)
					zeroCnt++;
			}
		}
		// rotates의 가능한 모든 경우를 나열하고, 
		// 각각의 경우에 대해서 물이 얼마나 차는지를 계산.
		getResult(0);
		printf("#%d %d\n", tt, zeroCnt - result);
	}
	return 0;
}
 ```

