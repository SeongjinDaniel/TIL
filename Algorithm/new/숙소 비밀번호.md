# 숙소 비밀번호

*시간제한 3초*

### 문제

------

이번에 유럽 여행을 가게 된 원영은 WaterBnB를 통해 숙소를 예약했다. 프랑스의 정취를 흠뻑 느끼기 위해서 역에서 15분가량 떨어진 곳으로 결정했다. 체크인 주의사항을 유심히 읽어보지 않은 체 툴루즈 블라냐크 공항에 도착하자마자 숙소로 돌진했다. 예약한 방에 들어가 짐을 풀려고 했으나 열쇠를 찾을 수 없었다. 다시 WaterBnB 앱을 켜 숙소 안내사항을 읽어보았다. 해당 숙소에서 방 열쇠를 얻기위해서는 열쇠함을 열어야됐다. 열쇠함에는 다이얼이 붙어있고 주어진 숫자를 조합하여 규칙에 맞는 숫자를 다이얼에 입력해야 열 수 있다.

규칙은 다음과 같다.

숫자의 개수는 18개이며, 각각의 숫자는 32진수로 주어진다. 주어진 수열의 순서를 섞을 수는 없다. 다이얼의 모양은 정육각형이며, 다이얼을 시계 방향 또는 반시계 방향으로 돌릴 수 있다. 다이얼 한 변에 3개의 숫자를 둘 수 있으며, 한 변에 있는 수열이 비밀번호 1개가 된다. 1회 회전할때마다 새로운 비밀번호들이 생성된다. 만약 같은 순서의 숫자조합을 가진 비밀번호가 있다면, 해당 비밀번호들은 같은 비밀번호로 생각한다.

생성된 비밀번호를 오름차순으로 정렬했을때, K 번째 비밀번호를 열쇠함을 열 수 있는 비밀번호로 설정되어있다. 비밀번호 입력은 육각 다이얼의 상단(빨간색)에서 이루어진다.

![hotel_password](https://alms-problem.s3.ap-northeast-2.amazonaws.com/hotel_password.png)

위와 같이 수열 "`0CPSF6D9ELA43ITVKN`"이 주어졌다고 가정했을때, 시계 방향으로 돌릴 경우 나올 수 있는 회전 회차별 비밀번호 조합은 다음과 같다.
0회차 - 0CP, SF6, D9E, LA4, 3IT, VKN
1회차 - N0C, PSF, 6D9, ELA, 43I, TVK
2회차 - KN0, CPS, F6D, 9EL, A43, ITV
3회차 - VKN, 0CP, SF6, D9E, LA4, 3IT
4회차 - TVK, N0C, PSF, 6D9, ELA, 43I
5회차 - ITV, KN0, CPS, F6D, 9EL, A43
6회차 - 3IT, VKN, 0CP, SF6, D9E, LA4
7회차 - 43I, TVK, N0C, PSF, 6D9, ELA
8회차 - A43, ITV, KN0, CPS, F6D, 9EL
9회차 - LA4, 3IT, VKN, 0CP, SF6, D9E
10회차 - ELA, 43I, TVK, N0C, PSF, 6D9
11회차 - 9EL, A43, ITV, KN0, CPS, F6D
12회차 - D9E, LA4, 3IT, VKN, 0CP, SF6
13회차 - 6D9, ELA, 43I, TVK, N0C, PSF
14회차 - F6D, 9EL, A43, ITV, KN0, CPS
15회차 - SF6, D9E, LA4, 3IT, VKN, 0CP
16회차 - PSF, 6D9, ELA, 43I, TVK, N0C
17회차 - CPS, F6D, 9EL, A43, ITV, KN0

다음은 반시계 방향으로 돌렸을 경우 얻어지는 회차별 비밀번호 조합이다.
0회차 - 0CP, SF6, D9E, LA4, 3IT, VKN
1회차 - CPS, F6D, 9EL, A43, ITV, KN0
2회차 - PSF, 6D9, ELA, 43I, TVK, N0C
3회차 - SF6, D9E, LA4, 3IT, VKN, 0CP
4회차 - F6D, 9EL, A43, ITV, KN0, CPS
5회차 - 6D9, ELA, 43I, TVK, N0C, PSF
6회차 - D9E, LA4, 3IT, VKN, 0CP, SF6
7회차 - 9EL, A43, ITV, KN0, CPS, F6D
8회차 - ELA, 43I, TVK, N0C, PSF, 6D9
9회차 - LA4, 3IT, VKN, 0CP, SF6, D9E
10회차 - A43, ITV, KN0, CPS, F6D, 9EL
11회차 - 43I, TVK, N0C, PSF, 6D9, ELA
12회차 - 3IT, VKN, 0CP, SF6, D9E, LA4
13회차 - ITV, KN0, CPS, F6D, 9EL, A43
14회차 - TVK, N0C, PSF, 6D9, ELA, 43I
15회차 - VKN, 0CP, SF6, D9E, LA4, 3IT
16회차 - KN0, CPS, F6D, 9EL, A43, ITV
17회차 - N0C, PSF, 6D9, ELA, 43I, TVK

생성된 비밀번호를 중복없이 오름차순으로 나열할 경우, 0CP 3IT 43I 6D9 9EL A43 D9E CPS ELA F6D ITV KN0 LA4 N0C PSF SF6 TVK VKN 가 된다.
이때, K 가 15 인 경우 15 번째 비밀번호는 PSF 가 된다. PSF 를 얻기 위해서는 다이얼을 반시계 방향으로 2회 돌리는 것이 최소 회전 횟수이다.

시차 적응이 안된 원영은 현재 잠이 부족한 상태이다. 숙소 문을 어서 빨리 열어 짐을 풀고 쉬고 싶다. 다이얼에 적힌 32진수 수열이 주어졌을때, 비밀번호를 입력하는데에 필요한 최소 다이얼 회전 횟수와 열쇠함의 비밀번호를 10진수로 바꾼 값을 구해보자!

### 입력

------

첫 번째 줄에 테스트 케이스의 개수 T가 주어진다.(1 ≤ T ≤ 50) 다음 줄부터 T개의 테스트 케이스에 대한 정보가 주어진다. 각각의 테스트 케이스는 한 줄에 K와 수열을 공백을 통해 구분하여 입력된다. K는 몇 번째 비밀번호가 상자를 여는 비밀번호인지를 알려주는 값이며, 수열은 다이얼의 초기 상태를 뜻한다. K는 생성된 비밀번호 개수를 초과하지 않으며, 수열은 항상 18자리로 고정되어 있다. 또한, 각 숫자는 0이상 V이하이다. (A~V 는 대문자로 주어진다. A는 32진수에서 10이고, V는 31이다.)

### 출력

------

각 테스트 케이스에 대해서 "#t result"의 형식을 맞춰 출력한다. t는 테스트 케이스의 번호를 뜻하며, 1부터 시작한다. result는 문제를 해결한 결과값을 의미한다. 해당 문제에서는 최소 회전 횟수와 비밀번호를 10진수로 변환한 값이다.

### 예제 입력

```
3
15 0CPSF6D9ELA43ITVKN
15 0CPSF6D9ELA43NKNKN
4 OUFMDHJSBEPGVC36L4
```

### 예제 출력

```
#1 2 26511 
#2 3 24215 
#3 8 11737
```

 ```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAX = 20;
const int MMAX = 35000;
int k, pwdsLen, result[MAX], resultNum;
int cwOrder, ccwOrder;
char cw[MAX][MAX]; // 시계 방향
char ccw[MAX][MAX]; // 반시계 방향
bool check[MMAX];
void initializeTestcase() {
	cwOrder = 0, ccwOrder = 0, resultNum = 0;
	memset(cw, 0, sizeof(cw));
	memset(ccw, 0, sizeof(ccw));
	memset(check, 0, sizeof(check));
	memset(result, 0, sizeof(result));
}
void CwRotate() {
	for (int i = 0; i < 17; i++) { // 0 ~ 16
		char temp[1];
		temp[0] = cw[i][17];
		for (int j = 17; j >= 1; j--) {
			cw[i+1][j] = cw[i][j - 1];
		}
		cw[i+1][0] = temp[0];
	}
}
void CcwRotate() {
	for (int i = 0; i < 17; i++) { // 0 ~ 16
		char temp[1];
		temp[0] = ccw[i][0];
		for (int j = 1; j < 18; j++) {
			ccw[i + 1][j-1] = ccw[i][j];
		}
		ccw[i + 1][17] = temp[0];
	}
}
void getMinOrder() {
	for (int i = 0; i < 18; i++) {
		char temp[3];
		for (int j = 0; j < 3; j++) {
			temp[j] = cw[i][j];
		}
		int tempNum = strtol(temp, NULL, 32);
		if (resultNum == tempNum) {
			cwOrder = i;
			break;
		}
	}
	for (int i = 0; i < 18; i++) {
		char temp[3];
		for (int j = 0; j < 3; j++) {
			temp[j] = ccw[i][j];
		}
		int tempNum = strtol(temp, NULL, 32);
		if (resultNum == tempNum) {
			ccwOrder = i;
			break;
		}
	}
}
int main() {
	int t;
	scanf("%d", &t);
	for (int tt = 1; tt <= t; tt++) {
		initializeTestcase();
		scanf("%d %s", &k, cw[0]);
		strcpy(ccw[0], cw[0]);
		CwRotate();
		CcwRotate();
		char temp[3] = { 0 };
		int irx = 0;
		int idx = 0;
		for (int i = 0; i < 6; i++) {
			idx = 0;
			for (int j = 0; j < 18; j++) {
				temp[idx++] = cw[i][j];
				if (idx % 3 == 0) {
					idx = 0;
					int tmpNum = strtol(temp, NULL, 32);
					if (!check[tmpNum]) {
						check[tmpNum] = true;
						result[irx++] = tmpNum;
					}
				}
			}
		}
		sort(result, result + irx);
		resultNum = result[k - 1];
		getMinOrder();
		int retOrder = ccwOrder > cwOrder ? cwOrder : ccwOrder;
		printf("#%d %d %d\n", tt, retOrder, resultNum);
	}
	return 0;
}
 ```

